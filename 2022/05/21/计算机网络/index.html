<!DOCTYPE html>
<html style="display: none;" lang="en">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/bollnh/hexo-theme-material
        Version: 1.5.6 -->
    <script>
        window.materialVersion = "1.5.6"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0',
            '1.5.2',
            '1.5.5'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">





    <link rel="dns-prefetch" href="https://.disqus.com"/>





    <link rel="dns-prefetch" href="https://fonts.googleapis.com"/>





    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            计算机网络 | 
        
        Winky&#39;s Blog
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.svg">
    <link rel="icon" href="/img/favicon.svg">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?uVzgA6RLrOm13Ukw8Qgy+A==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?ezyEvm8ST5CGfpA+kFFi1g==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Winky&#39;s Blog">
    <meta name="msapplication-starturl" content="http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Winky&#39;s Blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.svg">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="计算机网络 | Winky&#39;s Blog">
    <meta property="og:image" content="/img/favicon.svg">
    <meta property="og:description" content="">
    

    
        <meta property="article:published_time" content="Sat May 21 2022 21:03:41 GMT+0800">
        <meta property="article:modified_time" content="Tue Jan 17 2023 17:39:40 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html",
    "headline": "计算机网络",
    "datePublished": "Sat May 21 2022 21:03:41 GMT+0800",
    "dateModified": "Tue Jan 17 2023 17:39:40 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "Winky",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "This is Winky's blog!"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Winky&#39;s Blog",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.svg"
        }
    },
    "keywords": "",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Winky's Blog" type="application/atom+xml">
</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%88%86%E5%B1%82"><span class="post-toc-number">1.</span> <span class="post-toc-text">分层</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="post-toc-number">2.</span> <span class="post-toc-text">键入网址到网页显示，期间发生了什么？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TCP"><span class="post-toc-number">3.</span> <span class="post-toc-text">TCP</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="post-toc-number">4.</span> <span class="post-toc-text">TCP 连接建立</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">为什么是三次握手？不是两次、四次？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%98%BB%E6%AD%A2%E9%87%8D%E5%A4%8D%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%EF%BC%89"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">阻止重复历史连接的初始化（主要原因）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%8C%E6%96%B9%E7%9A%84%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">同步双方的初始序列号</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%81%BF%E5%85%8D%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9"><span class="post-toc-number">4.1.3.</span> <span class="post-toc-text">避免资源浪费</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="post-toc-number">4.1.4.</span> <span class="post-toc-text">小结</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="post-toc-number">5.</span> <span class="post-toc-text">第一次握手丢失会发生什么</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="post-toc-number">6.</span> <span class="post-toc-text">第二次握手丢失会发生什么</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="post-toc-number">7.</span> <span class="post-toc-text">第三次握手丢失会发生什么</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#SYN%E6%94%BB%E5%87%BB"><span class="post-toc-number">8.</span> <span class="post-toc-text">SYN攻击</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80"><span class="post-toc-number">9.</span> <span class="post-toc-text">TCP 连接断开</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">为什么是四次</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="post-toc-number">10.</span> <span class="post-toc-text">第一次挥手丢失会发生什么</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="post-toc-number">11.</span> <span class="post-toc-text">第二次挥手丢失会发生什么</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="post-toc-number">12.</span> <span class="post-toc-text">第三次挥手丢失会发生什么</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="post-toc-number">13.</span> <span class="post-toc-text">第四次挥手丢失会发生什么</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2MSL%EF%BC%9F"><span class="post-toc-number">14.</span> <span class="post-toc-text">为什么 TIME_WAIT 等待的时间是 2MSL？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81TIME-WAIT%E7%8A%B6%E6%80%81"><span class="post-toc-number">15.</span> <span class="post-toc-text">为什么要TIME_WAIT状态</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TCP%E4%B8%BA%E5%95%A5%E6%98%AF%E5%8F%AF%E9%9D%A0%E7%9A%84"><span class="post-toc-number">16.</span> <span class="post-toc-text">TCP为啥是可靠的</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">重传机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="post-toc-number">16.1.1.</span> <span class="post-toc-text">超时重传</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="post-toc-number">16.1.2.</span> <span class="post-toc-text">快速重传</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SACK%E9%80%89%E6%8B%A9%E6%80%A7%E7%A1%AE%E8%AE%A4"><span class="post-toc-number">16.1.3.</span> <span class="post-toc-text">SACK选择性确认</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="post-toc-number">16.2.</span> <span class="post-toc-text">滑动窗口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="post-toc-number">16.3.</span> <span class="post-toc-text">流量控制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="post-toc-number">16.4.</span> <span class="post-toc-text">拥塞控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="post-toc-number">16.4.1.</span> <span class="post-toc-text">慢启动</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="post-toc-number">16.4.2.</span> <span class="post-toc-text">拥塞避免算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="post-toc-number">16.4.3.</span> <span class="post-toc-text">拥塞发生</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="post-toc-number">16.4.4.</span> <span class="post-toc-text">快速恢复</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#UDP-TCP%EF%BC%9F"><span class="post-toc-number">17.</span> <span class="post-toc-text">UDP TCP？</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TCP-Keepalive-%E5%92%8C-HTTP-Keep-Alive"><span class="post-toc-number">18.</span> <span class="post-toc-text">TCP Keepalive 和 HTTP Keep-Alive</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP-%E7%9A%84-Keep-Alive"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">HTTP 的 Keep-Alive</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#TCP-%E7%9A%84-Keepalive"><span class="post-toc-number">18.2.</span> <span class="post-toc-text">TCP 的 Keepalive</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-number">18.3.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#HTTP-%E4%B8%8E-HTTPS"><span class="post-toc-number">19.</span> <span class="post-toc-text">HTTP 与 HTTPS</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP-%E4%B8%8E-HTTPS-%E5%8C%BA%E5%88%AB"><span class="post-toc-number">19.1.</span> <span class="post-toc-text">HTTP 与 HTTPS 区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTPS"><span class="post-toc-number">19.2.</span> <span class="post-toc-text">HTTPS</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="post-toc-number">19.2.1.</span> <span class="post-toc-text">混合加密</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="post-toc-number">19.2.2.</span> <span class="post-toc-text">摘要算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="post-toc-number">19.2.3.</span> <span class="post-toc-text">数字证书</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Cookie%E4%B8%8ESession%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="post-toc-number">20.</span> <span class="post-toc-text">Cookie与Session的对比</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                计算机网络
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Winky</strong>
        <span>May 21, 2022</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=计算机网络&url=http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html&via=Winky" target="_blank">
            <li class="mdl-menu__item">
                Share to Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html" target="_blank">
            <li class="mdl-menu__item">
                Share to Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html" target="_blank">
            <li class="mdl-menu__item">
                Share to Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657506890803-2f92c24f-e677-4640-aad6-29370dc5f594.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u82bc0f33&margin=%5Bobject%20Object%5D&originHeight=421&originWidth=731&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3fa4f199-bb77-4569-bce1-4f708cb396f&title="></p>
<h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><p>1、首先，在浏览器地址栏中输入url<br>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。<br>3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。<br>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。<br>5、握手成功后，浏览器向服务器发送http请求，请求数据包。<br>6、服务器处理收到的请求，将数据返回至浏览器<br>7、浏览器收到HTTP响应<br>8、读取页面内容，浏览器渲染，解析html源码<br>9、生成Dom树、解析css样式、js交互<br>10、客户端和服务器交互</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p>
</li>
<li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p>
</li>
<li><p><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p>
<h1 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h1><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456521938-f84cf61e-05a5-4a44-97cd-e58e4a108634.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u947fa551&margin=%5Bobject%20Object%5D&originHeight=1019&originWidth=1221&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e53449d-e6dc-4c0b-8881-4b0c8300f7e&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456537239-5309a313-193a-4ebd-a21c-b4e33a0784ef.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b1b72e4&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=1173&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua41d35f8-a61d-42ff-867f-79c01ad4340&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456545095-0909cf57-8a7f-446b-ab40-2ef35e100fc3.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9eab8a7a&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue2bb6658-e374-492f-91da-95111a8d8e2&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456549423-555f88b7-8905-4768-a92b-1e335c3e5dad.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u03125089&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua46a8691-bb1d-4cfa-8273-ad72aa59ea2&title="></p>
</li>
<li><p>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</p>
</li>
<li><p>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</p>
</li>
<li><p>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</p>
</li>
<li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务器的数据</strong>，之后客户端处于 ESTABLISHED 状态。</p>
</li>
<li><p>服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。</p>
</li>
</ul>
<p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p>
<h2 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h2><ul>
<li><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></li>
<li><strong>三次握手才可以同步双方的初始序列号</strong></li>
<li><strong>三次握手才可以避免资源浪费</strong></li>
</ul>
<h3 id="阻止重复历史连接的初始化（主要原因）"><a href="#阻止重复历史连接的初始化（主要原因）" class="headerlink" title="阻止重复历史连接的初始化（主要原因）"></a>阻止重复历史连接的初始化（主要原因）</h3><p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong><br>我们考虑一个场景，客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的）。<br>客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 SYN + ACK 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li>
</ul>
<p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p>
<h3 id="同步双方的初始序列号"><a href="#同步双方的初始序列号" class="headerlink" title="同步双方的初始序列号"></a>同步双方的初始序列号</h3><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong><br>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。<br>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456995831-a3b5cee7-a469-4a0a-aa57-5455dfd07f53.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7e94c947&margin=%5Bobject%20Object%5D&originHeight=947&originWidth=1442&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc4f73397-2e2e-4fea-9d8a-6b6d4b453bb&title="></p>
<h3 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h3><p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？<br>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。<br>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li><p>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</p>
</li>
<li><p>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>
<h1 id="第一次握手丢失会发生什么"><a href="#第一次握手丢失会发生什么" class="headerlink" title="第一次握手丢失会发生什么"></a>第一次握手丢失会发生什么</h1><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。<br>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。<br>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<h1 id="第二次握手丢失会发生什么"><a href="#第二次握手丢失会发生什么" class="headerlink" title="第二次握手丢失会发生什么"></a>第二次握手丢失会发生什么</h1><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。<br>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p>
</li>
<li><p>第二次握手里的 ACK， 是对第一次握手的确认报文；</p>
</li>
<li><p>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</p>
</li>
</ul>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。<br>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。<br>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<h1 id="第三次握手丢失会发生什么"><a href="#第三次握手丢失会发生什么" class="headerlink" title="第三次握手丢失会发生什么"></a>第三次握手丢失会发生什么</h1><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。<br>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。<br>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h1 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h1><p>攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务器不能为正常用户服务。<br>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li>
<li>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接。</li>
</ul>
<p><strong>避免方式：</strong></p>
<ol>
<li>修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理</li>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」，计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端。服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」，最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。<h1 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h1>TCP 断开连接是通过<strong>四次挥手</strong>方式。<br>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657458284824-44c6dbf7-9e4b-402e-bb97-47fab2391e3e.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7429d3fe&margin=%5Bobject%20Object%5D&originHeight=794&originWidth=753&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u31713d17-09f1-4320-a1d8-360e535e32d&title="></li>
</ol>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li>
<li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。</li>
<li>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li>
<li>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</li>
<li>服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h2 id="为什么是四次"><a href="#为什么是四次" class="headerlink" title="为什么是四次"></a>为什么是四次</h2><ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h1 id="第一次挥手丢失会发生什么"><a href="#第一次挥手丢失会发生什么" class="headerlink" title="第一次挥手丢失会发生什么"></a>第一次挥手丢失会发生什么</h1><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN_WAIT_1 状态。<br>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 FIN_WAIT2状态。<br>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。<br>当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，直接进入到 close 状态。</p>
<h1 id="第二次挥手丢失会发生什么"><a href="#第二次挥手丢失会发生什么" class="headerlink" title="第二次挥手丢失会发生什么"></a>第二次挥手丢失会发生什么</h1><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。<br>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。<br>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 FIN_WAIT2 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。<br>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以FIN_WAIT2 状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。<br>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。<br>但是注意，如果主动关闭方使用 shutdown 函数关闭连接且指定只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态（tcp_fin_timeout 无法控制 shutdown 关闭的连接）。</p>
<h1 id="第三次挥手丢失会发生什么"><a href="#第三次挥手丢失会发生什么" class="headerlink" title="第三次挥手丢失会发生什么"></a>第三次挥手丢失会发生什么</h1><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。<br>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。<br>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。<br>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<h1 id="第四次挥手丢失会发生什么"><a href="#第四次挥手丢失会发生什么" class="headerlink" title="第四次挥手丢失会发生什么"></a>第四次挥手丢失会发生什么</h1><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。<br>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。<br>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。<br>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p>
<h1 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h1><p>MSL 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。<br>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<br>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。<br>2MSL 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<h1 id="为什么要TIME-WAIT状态"><a href="#为什么要TIME-WAIT状态" class="headerlink" title="为什么要TIME_WAIT状态"></a>为什么要TIME_WAIT状态</h1><ul>
<li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p>
</li>
<li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p>
<h1 id="TCP为啥是可靠的"><a href="#TCP为啥是可靠的" class="headerlink" title="TCP为啥是可靠的"></a>TCP为啥是可靠的</h1><p>TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？<br>为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。<br>那么，TCP 是通过<strong>序列号、确认应答、重发控制、连接管理以及窗口控制</strong>等机制实现可靠性传输的。</p>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。<br>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。<br>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？<br>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459050264-9c22dcd5-b827-447f-b70a-6b00c0a159ea.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua94b36bb&margin=%5Bobject%20Object%5D&originHeight=846&originWidth=1412&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued85328b-c10c-49d0-84d0-086bc18eca4&title="><br>上图中有两种超时时间不同的情况：</p>
</li>
<li><p>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</p>
</li>
<li><p>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</p>
</li>
</ul>
<p>精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效。<br>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459073826-f018dd25-7288-47f9-82c0-07e4d02fd630.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubae8de8c&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=617&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3fe19c4-ea72-4bad-a23c-bd66c60eaed&title="></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459110193-082587bb-014e-4b8c-9032-cecf428a4887.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud67dd2b9&margin=%5Bobject%20Object%5D&originHeight=602&originWidth=647&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc3f797e0-ef7f-4057-b45b-d724dc47a08&title="></p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong><br>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<h3 id="SACK选择性确认"><a href="#SACK选择性确认" class="headerlink" title="SACK选择性确认"></a>SACK选择性确认</h3><p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459390363-dd685ad6-bd40-4ced-bdf8-3dc001dc1a70.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc09eb19e&margin=%5Bobject%20Object%5D&originHeight=827&originWidth=1413&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc5224ae5-3725-45f9-8e8f-9fdc82b83f4&title="></p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。但这种方式的缺点是效率比较低的。<br>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。<br>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。<br>窗口的实现实际上是操作系统开辟的一个<strong>缓存空间</strong>，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459480149-a3bdfb45-2815-4d33-801f-3692623051f4.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u65896e03&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=1428&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf16a8c9f-feef-40c6-b42b-4e5939dc76c&title="></p>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
<p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 52</del>56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459524511-0327b0f3-4ed4-49a2-a8ac-2896c3549616.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u432e4b08&margin=%5Bobject%20Object%5D&originHeight=408&originWidth=1608&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e92b946-0c5c-42a6-9022-10fa6049867&title="><br>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459579804-e07d32e1-48d2-4dc9-8e66-b1e196ea55e2.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udd9a001c&margin=%5Bobject%20Object%5D&originHeight=513&originWidth=1428&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u651d5b82-f0df-4fea-aad1-6c54417f4b8&title="></p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。<br>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。<br>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<br><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong><br>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。<br>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong><br>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。<br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。<br>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。<br>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li><p>只要网络中没有出现拥塞，cwnd 就会增大；</p>
</li>
<li><p>但网络中出现了拥塞，cwnd 就减少；</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？<br>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong><br>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657461768939-be8acba1-fd9f-45c4-a1c7-bb37f6e65332.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udc2211dd&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub7fc6573-4c83-42b7-a626-34c727c401b&title="><br>有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。</p>
</li>
<li><p>当 cwnd &lt; ssthresh 时，使用慢启动算法。</p>
</li>
<li><p>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。</p>
<h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。<br>一般来说 ssthresh 的大小是 65535 字节。<br>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong><br>接上前面的慢启动的栗子，现假定 ssthresh 为 8：</p>
</li>
<li><p>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了<strong>线性增长。</strong></p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657461857410-a908980d-c4bb-496a-856c-5ec22b16afd1.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua60403ab&margin=%5Bobject%20Object%5D&originHeight=731&originWidth=872&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u09c01fcb-49bf-4050-bb70-1c35d1fc106&title="><br>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。<br>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>当发生了「<strong>超时重传</strong>」，则就会使用拥塞发生算法。<br>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li>ssthresh 设为 cwnd/2，</li>
<li>cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657462092168-b3c9f1b3-e086-4a17-a736-5c53ca236143.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a1a80e5&margin=%5Bobject%20Object%5D&originHeight=873&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5c38a9f4-aabb-49a6-be85-2760a7fc4ba&title="></p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p><strong>快速重传</strong>和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。<br>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p>
<ul>
<li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li>
<li>ssthresh = cwnd;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657463742741-743bc69f-3471-4d92-b5f9-81dbc70de2b4.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u02d28309&margin=%5Bobject%20Object%5D&originHeight=873&originWidth=1352&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud229e954-b981-41df-b5ef-2fd578cebda&title="></p>
<h1 id="UDP-TCP？"><a href="#UDP-TCP？" class="headerlink" title="UDP TCP？"></a>UDP TCP？</h1><ul>
<li>UDP是<strong>无连接的</strong>；</li>
<li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP是<strong>面向报文</strong>的；</li>
<li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li>
<li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li>
<li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li>
</ul>
<p>那么，再说一次TCP的特点：</p>
<ul>
<li><p><strong>TCP是面向连接的</strong>。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（<strong>一对一</strong>）；</p>
</li>
<li><p>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</p>
</li>
<li><p>TCP<strong>提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
</li>
<li><p><strong>面向字节流</strong>。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
<h1 id="TCP-Keepalive-和-HTTP-Keep-Alive"><a href="#TCP-Keepalive-和-HTTP-Keep-Alive" class="headerlink" title="TCP Keepalive 和 HTTP Keep-Alive"></a>TCP Keepalive 和 HTTP Keep-Alive</h1><p>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p>
</li>
<li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p>
</li>
<li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p>
<h2 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h2><table>
<thead>
<tr>
<th>Http 1.0 短链接</th>
<th>Http 1.1 长链接</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657504730983-89ddfecf-3f13-4bb8-a93e-7fbbf55b8962.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u839c6483&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1067&originWidth=386&originalType=url&ratio=1&rotation=0&showTitle=false&size=72515&status=done&style=none&taskId=u1f5ed88c-acb7-43f9-8ff6-1f25a4a2dcd&title=" alt="image.png"></td>
<td><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657504758881-a72157de-0634-4dba-bc58-8c4d849f9b27.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1347d142&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1067&originWidth=386&originalType=url&ratio=1&rotation=0&showTitle=false&size=61840&status=done&style=none&taskId=ucfd7e6ed-4e54-4a0e-824b-e5ed5b1cd27&title=" alt="image.png"></td>
</tr>
</tbody></table>
</li>
</ul>
<p>HTTP 的 Keep-Alive 可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。<br><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive。</strong><br>为了避免资源浪费的情况，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<h2 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h2><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657504965949-5cc5a087-49f6-48c7-98c9-2b53bc20b534.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udd592f8c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=810&originWidth=833&originalType=url&ratio=1&rotation=0&showTitle=false&size=67650&status=done&style=none&taskId=u5f8b2031-027a-4f82-bd90-d8dcfb74aa7&title=" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</li>
<li>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。<h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><h2 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h2></li>
</ul>
<ol>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657505887909-c7ca431c-dec5-47ff-8ced-20c8fa0fc250.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u436c7bc2&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=596&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0350652e-608b-4f32-9160-4961ed0ae97&title="><br>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><p><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</p>
</li>
<li><p><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</p>
</li>
<li><p><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2></li>
<li><p><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p>
</li>
<li><p><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
</li>
<li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657506133791-a190fe08-e2c0-45fe-8e07-1b921ed067b6.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7235e8ff&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=613&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6742655-c857-4ba2-a1ad-29b2b97815e&title="><br>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
</li>
<li><p>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</p>
</li>
<li><p>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</p>
</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</li>
</ul>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657506280631-2233b593-67d1-48c4-9248-8341b45137e7.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9ee13cd5&margin=%5Bobject%20Object%5D&originHeight=577&originWidth=779&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u261c32c4-ceb1-43dd-8182-857282c3317&title="><h1 id="Cookie与Session的对比"><a href="#Cookie与Session的对比" class="headerlink" title="Cookie与Session的对比"></a>Cookie与Session的对比</h1>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</li>
</ul>
<p><strong>Cookie</strong></p>
<ul>
<li>Cookie是客户端保持状态的方法。Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</li>
</ul>
<p><strong>Session</strong></p>
<ul>
<li>Session是服务器保持状态的方法。首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</li>
</ul>
<p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
    <!-- 使用 DISQUS -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>
<script type="text/ls-javascript" id="disqus-thread-script">
    queue.offer(function() {
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document;
                var s = d.createElement('script');
                s.src = '//.disqus.com/embed.js';
                s.setAttribute('data-timestamp', + new Date());
                (d.head || d.body).appendChild(s);
            })();
        });
</script>

</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>

                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2022/05/22/Spring/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Newer
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2022/05/20/Mysql/" id="post_nav-older" class="next-content">
            Older
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Winky's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        winky1230@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                Home
            </a>
        </li>
        
            <li class="divider"></li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    Archives
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2022/05/">May 2022<span class="sidebar_archives-count">3</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                Categories
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/java/">java<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/categories/java/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发<span class="sidebar_archives-count">3</span></a>
            </ul>
        </li>
        
            <li class="divider"></li>
        
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
        <li>
            <a href="/archives">
                Number of articles
                <span class="sidebar-badge">3</span>
            </a>
        </li>
        
            <li class="divider"></li>
        
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->


<!-- Theme Material -->


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    

    <!-- V2EX -->
    

    <!-- Segmentfault -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;<span year></span>&nbsp;Winky's Blog
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/bollnh/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?wgjW/HuQG9JDgvPDPoRAng==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?LT4t6iE6m8TO1BLGGiNJqA==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    
        <script>lsloader.load("sm_js","/js/smoothscroll.js?tNQK2Tw2SUL8a1Scn/Mgew==", true)</script>
    







   <!-- 使用 DISQUS js 代码 -->
<script id="dsq-count-scr" src="//.disqus.com/count.js" async></script>





<!-- UC Browser Compatible -->
<!-- <script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('
<link rel="stylesheet" href="/css/uc.css">
');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script> -->

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    var copyrightNow = new Date().getFullYear();
    var textContent = document.querySelector('span[year]')

    copyrightSince = 0000;
    if (copyrightSince === copyrightNow||copyrightSince === 0000) {
        textContent.textContent = copyrightNow
    } else {
        textContent.textContent = copyrightSince + ' - ' + copyrightNow
    }

    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.6 | https://github.com/bollnh/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
