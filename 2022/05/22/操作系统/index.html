<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>操作系统 - Winky&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Winky Granger"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Winky Granger"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="操作系统基础知识"><meta property="og:type" content="blog"><meta property="og:title" content="操作系统"><meta property="og:url" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><meta property="og:site_name" content="Winky&#039;s Blog"><meta property="og:description" content="操作系统基础知识"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658146534047-a200795a-9aad-4eae-b0cc-c17df81a3f03.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643001593-35048363-b135-4161-9a30-4c184493dca2.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643772980-833f7727-579a-4fd6-95f9-2d73382c28b1.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157424101-9c5d3320-4b20-4459-801c-a94d8e7f4a9c.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157467622-4d68b3f0-01f7-41f1-9b49-69906b69339f.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157534537-7b08b675-a40f-41ed-95c3-7faf870ca7f3.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157550287-c44edf86-87c9-4b8c-a08a-e68e736df1ee.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157564861-c16c83be-d673-417d-831e-b50617f728e7.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157596450-42cb6f02-711c-49b8-ab9c-e87fec40db9a.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157617052-e7ab12d7-76a6-4ea5-a3f8-7a6c3fb9fbf8.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157633365-8807891a-c046-45a4-bc2d-ef207c45ce82.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157649661-df255dd3-3482-4cc6-9d42-59cf5407d02e.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157658029-8e23f390-085d-4784-9661-611d2d31bc04.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157672128-4ced56fb-a58e-449a-9b0b-66523b85dffe.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157690879-ac5982b5-e22a-4fb1-b25a-bcb992b488fa.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157704285-3c4bd803-d8f0-40a0-8f2b-0cb9ebf26a35.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157716803-dc8e2ce0-7f82-431a-8500-46e56df8bbc6.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157761743-17c43c42-06a3-4ca3-b39b-cf3483774828.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157779581-9aa43107-f932-42a6-9c1d-af2335e158f8.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157836867-f256ed5c-6a60-42f0-a520-d4bc1a50bc5e.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157860633-7ac128c9-a0e4-4166-bc2c-db2c029e9b76.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157876158-13a6e076-5253-4e59-8604-0bdfce151a9b.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157951018-84ad97a5-07db-48f8-a6dc-6fb440d6c976.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157983980-95ed9a46-5767-4537-a9fc-3fba4a51546b.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158012726-ffb3adac-99e8-4330-b9f7-9a4daf0aa9e3.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043661-63ad5a48-4ece-4133-95a2-6ee28bdb9bc1.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043696-c61c58b3-30e2-48f7-b5a2-7e596c8bd975.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158064389-438c1ea3-03e4-4ff8-885d-2c9dfd794d49.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158081123-76c74a83-6e9d-4ee9-9ecf-0e2f2341ddab.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158151854-76a4639d-52ca-47a8-9d62-b0460c969d29.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158112508-a2f932c5-e6f0-4068-a508-383bcbcf32d2.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158172464-cc257844-d0b8-4a33-af13-b1ee6ac8607a.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158204808-b681f6db-c97a-429b-bc25-83c3284341ae.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158224980-b659fd89-1faf-4643-a5cb-03eed5a12e68.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158234845-b04bc958-e489-49da-8b3f-9f721527a0d9.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158250381-97177780-526d-4d9d-9cd8-dfb93620167d.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158280081-393ad2c7-c4d6-4f99-868a-0e459b444219.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158298806-2e2738db-5545-415b-b57b-688ee329aa0d.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158311748-de2659ab-ad99-460a-82e0-816c56a39ac7.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158322354-aa473fff-e254-475e-bb59-9bc64e655325.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158335651-40908ec2-147a-4fbd-9488-1cc4617e521a.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158355786-1e819fc4-b028-4465-8351-d0375c4970e4.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158362257-e8928b4e-20f6-4df5-bac6-3e4fe059d1fb.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158371530-afdb3c2c-c7e4-4171-9c3e-c5f0076974bc.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158380064-7c1ffdd6-4694-4eb9-988a-83e5c2913470.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158388208-d4925211-477e-4e0c-8aef-67192ab0e4b5.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158399204-b53877bb-9c91-4d04-91b7-52d51625e80b.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158408049-8a0291b7-ebfb-4cdb-808c-3e14a3a164a0.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158417644-270d71f9-8e6f-4a09-9336-374fd69186e7.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158427495-5547f211-e57d-40fd-8ffe-680af304a7a4.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158438287-b7ac793f-f05c-4393-82c7-b5faae306617.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158450843-3a53646d-0ca9-4780-b220-58ca5b7e7722.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158483090-1d3ac7fd-23c4-45a1-90f8-2944000246a5.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158469108-6cf624dd-7ce3-444c-873d-a216fd36f049.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158501047-04a2ca45-549f-4ed6-a8d8-2d51bd28fdb8.png"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22222537/1658158518539-3d68ccd1-321e-41f8-b3db-b9df757810bb.png?x-oss-process=image/resize,w_750,limit_0"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158559714-a5dc5914-614c-4e1d-8698-60bbd7bfa485.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158526101-4f39919e-b815-4ca2-b63d-c0e554fff524.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158534958-e576259b-88f5-4d33-b8d6-9df4e626d1d0.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158580532-848e4291-1772-4116-9e1f-d2818f5b2613.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158591526-1b1a6d83-631f-4e5f-a7f2-692bd85bc18d.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158602935-29af1c8b-e82e-401f-a5a1-b6403477c4e2.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158617736-267af6e6-4c29-4018-b47f-cc5d2bbd8ebc.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158624171-04575605-acb3-4674-b007-27604d30e4e6.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158633543-d2a53e44-a662-4432-8002-c75cad6e4eec.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660451847923-06791649-8b89-47b1-a15b-681028a98022.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452134996-339c0cca-443a-48ad-ae35-341acd62e413.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452275840-a5850af5-955f-4084-be8e-8ed4e1b25d0c.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452616552-0d03877d-ca4e-4348-b0d8-e08f572a79b9.png"><meta property="og:image" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1659883620324-de53a65b-003b-4a6d-88df-e92155156f45.png"><meta property="article:published_time" content="2022-05-22T13:03:41.000Z"><meta property="article:modified_time" content="2023-01-21T08:56:34.189Z"><meta property="article:author" content="Winky"><meta property="article:tag" content="操作系统"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658146534047-a200795a-9aad-4eae-b0cc-c17df81a3f03.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},"headline":"操作系统","image":["https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658146534047-a200795a-9aad-4eae-b0cc-c17df81a3f03.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643001593-35048363-b135-4161-9a30-4c184493dca2.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643772980-833f7727-579a-4fd6-95f9-2d73382c28b1.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157424101-9c5d3320-4b20-4459-801c-a94d8e7f4a9c.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157467622-4d68b3f0-01f7-41f1-9b49-69906b69339f.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157534537-7b08b675-a40f-41ed-95c3-7faf870ca7f3.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157550287-c44edf86-87c9-4b8c-a08a-e68e736df1ee.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157564861-c16c83be-d673-417d-831e-b50617f728e7.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157596450-42cb6f02-711c-49b8-ab9c-e87fec40db9a.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157617052-e7ab12d7-76a6-4ea5-a3f8-7a6c3fb9fbf8.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157633365-8807891a-c046-45a4-bc2d-ef207c45ce82.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157649661-df255dd3-3482-4cc6-9d42-59cf5407d02e.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157658029-8e23f390-085d-4784-9661-611d2d31bc04.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157672128-4ced56fb-a58e-449a-9b0b-66523b85dffe.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157690879-ac5982b5-e22a-4fb1-b25a-bcb992b488fa.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157704285-3c4bd803-d8f0-40a0-8f2b-0cb9ebf26a35.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157716803-dc8e2ce0-7f82-431a-8500-46e56df8bbc6.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157761743-17c43c42-06a3-4ca3-b39b-cf3483774828.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157779581-9aa43107-f932-42a6-9c1d-af2335e158f8.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157836867-f256ed5c-6a60-42f0-a520-d4bc1a50bc5e.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157860633-7ac128c9-a0e4-4166-bc2c-db2c029e9b76.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157876158-13a6e076-5253-4e59-8604-0bdfce151a9b.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157951018-84ad97a5-07db-48f8-a6dc-6fb440d6c976.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157983980-95ed9a46-5767-4537-a9fc-3fba4a51546b.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158012726-ffb3adac-99e8-4330-b9f7-9a4daf0aa9e3.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043661-63ad5a48-4ece-4133-95a2-6ee28bdb9bc1.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043696-c61c58b3-30e2-48f7-b5a2-7e596c8bd975.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158064389-438c1ea3-03e4-4ff8-885d-2c9dfd794d49.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158081123-76c74a83-6e9d-4ee9-9ecf-0e2f2341ddab.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158151854-76a4639d-52ca-47a8-9d62-b0460c969d29.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158112508-a2f932c5-e6f0-4068-a508-383bcbcf32d2.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158172464-cc257844-d0b8-4a33-af13-b1ee6ac8607a.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158204808-b681f6db-c97a-429b-bc25-83c3284341ae.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158224980-b659fd89-1faf-4643-a5cb-03eed5a12e68.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158234845-b04bc958-e489-49da-8b3f-9f721527a0d9.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158250381-97177780-526d-4d9d-9cd8-dfb93620167d.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158280081-393ad2c7-c4d6-4f99-868a-0e459b444219.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158298806-2e2738db-5545-415b-b57b-688ee329aa0d.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158311748-de2659ab-ad99-460a-82e0-816c56a39ac7.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158322354-aa473fff-e254-475e-bb59-9bc64e655325.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158335651-40908ec2-147a-4fbd-9488-1cc4617e521a.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158355786-1e819fc4-b028-4465-8351-d0375c4970e4.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158362257-e8928b4e-20f6-4df5-bac6-3e4fe059d1fb.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158371530-afdb3c2c-c7e4-4171-9c3e-c5f0076974bc.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158380064-7c1ffdd6-4694-4eb9-988a-83e5c2913470.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158388208-d4925211-477e-4e0c-8aef-67192ab0e4b5.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158399204-b53877bb-9c91-4d04-91b7-52d51625e80b.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158408049-8a0291b7-ebfb-4cdb-808c-3e14a3a164a0.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158417644-270d71f9-8e6f-4a09-9336-374fd69186e7.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158427495-5547f211-e57d-40fd-8ffe-680af304a7a4.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158438287-b7ac793f-f05c-4393-82c7-b5faae306617.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158450843-3a53646d-0ca9-4780-b220-58ca5b7e7722.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158483090-1d3ac7fd-23c4-45a1-90f8-2944000246a5.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158469108-6cf624dd-7ce3-444c-873d-a216fd36f049.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158501047-04a2ca45-549f-4ed6-a8d8-2d51bd28fdb8.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158559714-a5dc5914-614c-4e1d-8698-60bbd7bfa485.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158526101-4f39919e-b815-4ca2-b63d-c0e554fff524.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158534958-e576259b-88f5-4d33-b8d6-9df4e626d1d0.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158580532-848e4291-1772-4116-9e1f-d2818f5b2613.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158591526-1b1a6d83-631f-4e5f-a7f2-692bd85bc18d.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158602935-29af1c8b-e82e-401f-a5a1-b6403477c4e2.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158617736-267af6e6-4c29-4018-b47f-cc5d2bbd8ebc.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158624171-04575605-acb3-4674-b007-27604d30e4e6.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158633543-d2a53e44-a662-4432-8002-c75cad6e4eec.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660451847923-06791649-8b89-47b1-a15b-681028a98022.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452134996-339c0cca-443a-48ad-ae35-341acd62e413.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452275840-a5850af5-955f-4084-be8e-8ed4e1b25d0c.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452616552-0d03877d-ca4e-4348-b0d8-e08f572a79b9.png","https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1659883620324-de53a65b-003b-4a6d-88df-e92155156f45.png"],"datePublished":"2022-05-22T13:03:41.000Z","dateModified":"2023-01-21T08:56:34.189Z","author":{"@type":"Person","name":"Winky"},"publisher":{"@type":"Organization","name":"Winky's Blog","logo":{"@type":"ImageObject","url":"https://winkygranger.github.io/img/logo.svg"}},"description":"操作系统基础知识"}</script><link rel="canonical" href="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xt256.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Winky's Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Winky&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">工牌旅行记</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WinkyGranger"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-22T13:03:41.000Z" title="2022/5/22 21:03:41">2022-05-22</time>发表</span><span class="level-item"><time dateTime="2023-01-21T08:56:34.189Z" title="2023/1/21 16:56:34">2023-01-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">1 小时读完 (大约9487个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">操作系统</h1><div class="content"><p>操作系统基础知识</p>
<span id="more"></span>

<h1 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h1><p>进程是系统资源分配和调度的最小单位、<br>线程是操作系统分配和调度的最小单位<br>线程分成更小的协程，多个协程共享一个线程。<br>线程切换是一个操作系统层面的行为，要关中断、保存断点、终端服务寻址、开中断执行服务<br>协程间切换是runtime的 行为<br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658146534047-a200795a-9aad-4eae-b0cc-c17df81a3f03.png"></p>
<h1 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h1><ul>
<li><p>时钟管理</p>
</li>
<li><p>中断机制</p>
<ul>
<li><p>外中断：中断信号来源于外部设备（被迫的）</p>
</li>
<li><p>内中断：中断信号来源于当前指令（自愿的）：</p>
<ul>
<li>陷入指令（应用程序引发的，cpu产生），比如程序执行到某处需要进行读文件操作，cpu从用户态切换到内核态</li>
<li>内存缺页中断<table>
<thead>
<tr>
<th><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643001593-35048363-b135-4161-9a30-4c184493dca2.png"></th>
<th><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643772980-833f7727-579a-4fd6-95f9-2d73382c28b1.png"></th>
</tr>
</thead>
</table>
</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>原语（原语的底层实现就是靠开中断和关中断实现的）</p>
<ul>
<li>若干条指令组成</li>
<li>完成某个特定功能</li>
<li>执行过程不会被中断（具有原子性）</li>
</ul>
</li>
<li><p>系统数据结构</p>
<ul>
<li>进程管理：作业控制快、进程控制块</li>
<li>存储器管理：存储器分配与回收</li>
<li>设备管理：缓冲区、设备控制快</li>
</ul>
</li>
<li><p>系统调用（应用程序去访问操作系统内核的时候）</p>
<ul>
<li>一套接口的集合</li>
<li>应用程序去访问操作系统内核服务的方式<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1></li>
</ul>
</li>
</ul>
<p><strong>PCB:<strong>为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为</strong>进程控制块</strong>（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。<br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157424101-9c5d3320-4b20-4459-801c-a94d8e7f4a9c.png"><br>寄存器里面放的是有些程序运行计算了一半被抢占了，记录执行的位置，下次执行可以接着中间数据往下执行<br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157467622-4d68b3f0-01f7-41f1-9b49-69906b69339f.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157534537-7b08b675-a40f-41ed-95c3-7faf870ca7f3.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157550287-c44edf86-87c9-4b8c-a08a-e68e736df1ee.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157564861-c16c83be-d673-417d-831e-b50617f728e7.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157596450-42cb6f02-711c-49b8-ab9c-e87fec40db9a.png"></p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul>
<li><strong>其实是七状态，还有阻塞挂起和就绪挂起</strong></li>
</ul>
<p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157617052-e7ab12d7-76a6-4ea5-a3f8-7a6c3fb9fbf8.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157633365-8807891a-c046-45a4-bc2d-ef207c45ce82.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157649661-df255dd3-3482-4cc6-9d42-59cf5407d02e.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157658029-8e23f390-085d-4784-9661-611d2d31bc04.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157672128-4ced56fb-a58e-449a-9b0b-66523b85dffe.png"></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="共享存储：共享空间对于多个进程访问是互斥的"><a href="#共享存储：共享空间对于多个进程访问是互斥的" class="headerlink" title="共享存储：共享空间对于多个进程访问是互斥的"></a><strong>共享存储</strong>：共享空间对于多个进程访问是互斥的</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157690879-ac5982b5-e22a-4fb1-b25a-bcb992b488fa.png"></p>
<h3 id="管道通信：没写满的时候是不允许读的，没读完也是不允许写的。"><a href="#管道通信：没写满的时候是不允许读的，没读完也是不允许写的。" class="headerlink" title="管道通信：没写满的时候是不允许读的，没读完也是不允许写的。"></a><strong>管道通信</strong>：没写满的时候是不允许读的，没读完也是不允许写的。</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157704285-3c4bd803-d8f0-40a0-8f2b-0cb9ebf26a35.png"></p>
<h3 id="消息队列：消息头里包含了传递信息，不会传错给别的进程"><a href="#消息队列：消息头里包含了传递信息，不会传错给别的进程" class="headerlink" title="消息队列：消息头里包含了传递信息，不会传错给别的进程"></a><strong>消息队列</strong>：消息头里包含了传递信息，不会传错给别的进程</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157716803-dc8e2ce0-7f82-431a-8500-46e56df8bbc6.png"></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字 socket"></a>套接字 socket</h3><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157761743-17c43c42-06a3-4ca3-b39b-cf3483774828.png" alt="image-20220525205412434.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157779581-9aa43107-f932-42a6-9c1d-af2335e158f8.png"></p>
<h2 id="线程的实现方式（用户级线程、内核级线程、组合方式）"><a href="#线程的实现方式（用户级线程、内核级线程、组合方式）" class="headerlink" title="线程的实现方式（用户级线程、内核级线程、组合方式）"></a>线程的实现方式（用户级线程、内核级线程、组合方式）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157836867-f256ed5c-6a60-42f0-a520-d4bc1a50bc5e.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157860633-7ac128c9-a0e4-4166-bc2c-db2c029e9b76.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157876158-13a6e076-5253-4e59-8604-0bdfce151a9b.png"></p>
<h2 id="多线程模型：多对一、一对多"><a href="#多线程模型：多对一、一对多" class="headerlink" title="多线程模型：多对一、一对多"></a>多线程模型：多对一、一对多</h2><p>n个用户级线程映射到内核级线程上</p>
<h1 id="处理机调度（线程调度）"><a href="#处理机调度（线程调度）" class="headerlink" title="处理机调度（线程调度）"></a>处理机调度（线程调度）</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157951018-84ad97a5-07db-48f8-a6dc-6fb440d6c976.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157983980-95ed9a46-5767-4537-a9fc-3fba4a51546b.png"></p>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><ol>
<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
<li><strong>临界区</strong>：拥有临界区的线程可以访问被保护资源，其他访问会被挂起。<ol>
<li>双标志前检查法：先检查其他进程是否想要临界区，再上锁</li>
<li>双标志后检查法：先上锁在检查其他进程是否想要临界区</li>
<li>Peterson算法：双方都争着使用临界区的话，可以尝试让一方主动让对方先使用临界区<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158012726-ffb3adac-99e8-4330-b9f7-9a4daf0aa9e3.png"><h2 id="临界区冲突"><a href="#临界区冲突" class="headerlink" title="临界区冲突"></a>临界区冲突</h2></li>
</ol>
</li>
</ol>
<ul>
<li><p>空闲让进：一次进一个，进不来的挂起</p>
</li>
<li><p>忙则等待：</p>
</li>
<li><p>有限等待：有限时间内退出</p>
</li>
<li><p>让权等待：进程不能进入自己的临界区，则应该让出CPU，避免出现忙等现象</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1></li>
<li><p>互斥条件：对必须互斥资源的争抢才会导致死锁</p>
</li>
<li><p>不剥夺条件：进程获得的资源在未使用完之前不能由其他进程强行夺走，只能主动释放</p>
</li>
<li><p>请求和保持条件：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求被阻塞，但又对自己的资源保持不放</p>
</li>
<li><p>循环等待条件：存在资源的循环等待链</p>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043661-63ad5a48-4ece-4133-95a2-6ee28bdb9bc1.png"></p>
</li>
</ul>
<p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043696-c61c58b3-30e2-48f7-b5a2-7e596c8bd975.png"></p>
<h2 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158064389-438c1ea3-03e4-4ff8-885d-2c9dfd794d49.png"></p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158081123-76c74a83-6e9d-4ee9-9ecf-0e2f2341ddab.png"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158151854-76a4639d-52ca-47a8-9d62-b0460c969d29.png"></p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>下图A调用B、C是依次调用的，因此B、C可以共同使用程序X的覆盖区0（图中绿色），从逻辑上看，物理内存是被”拓展“了</p>
<p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158112508-a2f932c5-e6f0-4068-a508-383bcbcf32d2.png"></p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158172464-cc257844-d0b8-4a33-af13-b1ee6ac8607a.png"></p>
<p><strong>换入、换出</strong></p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158204808-b681f6db-c97a-429b-bc25-83c3284341ae.png"></p>
<h2 id="管理方式（单一连续分配、固定分区分配方式"><a href="#管理方式（单一连续分配、固定分区分配方式" class="headerlink" title="管理方式（单一连续分配、固定分区分配方式)"></a>管理方式（单一连续分配、固定分区分配方式)</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158224980-b659fd89-1faf-4643-a5cb-03eed5a12e68.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158234845-b04bc958-e489-49da-8b3f-9f721527a0d9.png"></p>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158250381-97177780-526d-4d9d-9cd8-dfb93620167d.png"><br>不同的页面是<strong>离散</strong>地存放在内存中</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p><strong>每个进程都有自己的页表</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158280081-393ad2c7-c4d6-4f99-868a-0e459b444219.png"></p>
<p><strong>问题：</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158298806-2e2738db-5545-415b-b57b-688ee329aa0d.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158311748-de2659ab-ad99-460a-82e0-816c56a39ac7.png"><br><strong>相当于把以前的页表查分成多个页表，并为多个页表加一个目录，叫做”页目录表“</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158322354-aa473fff-e254-475e-bb59-9bc64e655325.png"></p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="传统存储"><a href="#传统存储" class="headerlink" title="传统存储"></a>传统存储</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158335651-40908ec2-147a-4fbd-9488-1cc4617e521a.png"><br><strong>例如，GTA游戏一共60G，电脑是4G的，如果要玩的话需要全部加载到内存中，显然是不够的，但是我在A场景时只用放入A场景的资源就可以了，而这种传统方式会需要整个游戏全部加驻留在内存中。</strong><br>虚拟内存基于<strong>局部性原理</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158355786-1e819fc4-b028-4465-8351-d0375c4970e4.png"></p>
<p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158362257-e8928b4e-20f6-4df5-bac6-3e4fe059d1fb.png"></p>
<h1 id="实现虚拟内存的技术"><a href="#实现虚拟内存的技术" class="headerlink" title="实现虚拟内存的技术"></a>实现虚拟内存的技术</h1><h2 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158371530-afdb3c2c-c7e4-4171-9c3e-c5f0076974bc.png"></p>
<h2 id="内存有空闲的情况"><a href="#内存有空闲的情况" class="headerlink" title="内存有空闲的情况"></a>内存有空闲的情况</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158380064-7c1ffdd6-4694-4eb9-988a-83e5c2913470.png"></p>
<h2 id="内存没空闲的情况"><a href="#内存没空闲的情况" class="headerlink" title="内存没空闲的情况"></a>内存没空闲的情况</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158388208-d4925211-477e-4e0c-8aef-67192ab0e4b5.png"></p>
<h2 id="请求分段存储管理"><a href="#请求分段存储管理" class="headerlink" title="请求分段存储管理"></a>请求分段存储管理</h2><h2 id="请求段页式存储管理"><a href="#请求段页式存储管理" class="headerlink" title="请求段页式存储管理"></a>请求段页式存储管理</h2><h1 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h1><h2 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158399204-b53877bb-9c91-4d04-91b7-52d51625e80b.png"></p>
<h2 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158408049-8a0291b7-ebfb-4cdb-808c-3e14a3a164a0.png"></p>
<h2 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158417644-270d71f9-8e6f-4a09-9336-374fd69186e7.png"></p>
<h2 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158427495-5547f211-e57d-40fd-8ffe-680af304a7a4.png"></p>
<ul>
<li>内存块排布类似于循环链表</li>
<li>到6页面的时候，由于5个内存块都满了，就需要先箭头转一圈全部置为0，然后替换最开始的位置，后面用到的继续置为1，全为1的时候再转一圈变为0，然后又从队首开始替换。箭头扫描的过程有点像时钟转，故命名为时钟置换算法。<h2 id="改造型的时钟置换算法"><a href="#改造型的时钟置换算法" class="headerlink" title="改造型的时钟置换算法"></a>改造型的时钟置换算法</h2><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158438287-b7ac793f-f05c-4393-82c7-b5faae306617.png"><br>因为之前说到分页存储的时候，再替换过程中如果一个页面被修改过，则需要写入外存中去。这个时候给他加一个标记，被修改过的时候修改位标记为1。</li>
</ul>
<h1 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158450843-3a53646d-0ca9-4780-b220-58ca5b7e7722.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158483090-1d3ac7fd-23c4-45a1-90f8-2944000246a5.png"></p>
<h2 id="活动头磁盘、固定头磁盘"><a href="#活动头磁盘、固定头磁盘" class="headerlink" title="活动头磁盘、固定头磁盘"></a>活动头磁盘、固定头磁盘</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158469108-6cf624dd-7ce3-444c-873d-a216fd36f049.png"></p>
<h2 id="写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）"><a href="#写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）" class="headerlink" title="写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）"></a>写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158501047-04a2ca45-549f-4ed6-a8d8-2d51bd28fdb8.png"></p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><h2 id="最短寻找时间优先"><a href="#最短寻找时间优先" class="headerlink" title="最短寻找时间优先"></a>最短寻找时间优先</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1658158518539-3d68ccd1-321e-41f8-b3db-b9df757810bb.png?x-oss-process=image/resize,w_750,limit_0" alt="image-20220528113135927.png"></p>
<h2 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158559714-a5dc5914-614c-4e1d-8698-60bbd7bfa485.png"></p>
<h2 id="LOOK调度算法（扫描算法改进）"><a href="#LOOK调度算法（扫描算法改进）" class="headerlink" title="LOOK调度算法（扫描算法改进）"></a>LOOK调度算法（扫描算法改进）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158526101-4f39919e-b815-4ca2-b63d-c0e554fff524.png"></p>
<h2 id="循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均"><a href="#循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均" class="headerlink" title="循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均"></a>循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158534958-e576259b-88f5-4d33-b8d6-9df4e626d1d0.png"></p>
<h2 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158580532-848e4291-1772-4116-9e1f-d2818f5b2613.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158591526-1b1a6d83-631f-4e5f-a7f2-692bd85bc18d.png"></p>
<h2 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h2><h3 id="交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题"><a href="#交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题" class="headerlink" title="交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题"></a>交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158602935-29af1c8b-e82e-401f-a5a1-b6403477c4e2.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158617736-267af6e6-4c29-4018-b47f-cc5d2bbd8ebc.png"></p>
<h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158624171-04575605-acb3-4674-b007-27604d30e4e6.png"></p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158633543-d2a53e44-a662-4432-8002-c75cad6e4eec.png"></p>
<h1 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660451847923-06791649-8b89-47b1-a15b-681028a98022.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452134996-339c0cca-443a-48ad-ae35-341acd62e413.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452275840-a5850af5-955f-4084-be8e-8ed4e1b25d0c.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452616552-0d03877d-ca4e-4348-b0d8-e08f572a79b9.png"></p>
<h1 id="什么是操作系统？请简要概述一下"><a href="#什么是操作系统？请简要概述一下" class="headerlink" title="什么是操作系统？请简要概述一下"></a>什么是操作系统？请简要概述一下</h1><p>操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。<br>向上对用户程序提供接口，向下接管硬件资源。<br>操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。 </p>
<h1 id="操作系统有哪些分类？"><a href="#操作系统有哪些分类？" class="headerlink" title="操作系统有哪些分类？"></a>操作系统有哪些分类？</h1><p>操作系统常规可分为批处理操作系统、分时操作系统、实时操作系统。<br>若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。<br>常见的通用操作系统有：Windows、Linux、MacOS等。 </p>
<h1 id="什么是内核态和用户态？"><a href="#什么是内核态和用户态？" class="headerlink" title="什么是内核态和用户态？"></a>什么是内核态和用户态？</h1><p>为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。<br>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。<br>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。<br>用户程序运行在用户态,操作系统内核运行在内核态。 </p>
<h1 id="如何实现内核态和用户态的切换？"><a href="#如何实现内核态和用户态的切换？" class="headerlink" title="如何实现内核态和用户态的切换？"></a>如何实现内核态和用户态的切换？</h1><p>处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。 </p>
<ol>
<li><p>系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。 </p>
</li>
<li><p>异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。 </p>
</li>
<li><p>外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。 </p>
<h1 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h1></li>
<li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。 </p>
</li>
<li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。 </p>
<h1 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h1><p>进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。<br>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。<br>上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。<br>进程一般由以下的部分组成： </p>
</li>
<li><p>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。 </p>
</li>
<li><p>程序段 </p>
</li>
<li><p>数据段 </p>
</li>
</ol>
<h1 id="进程的基本操作"><a href="#进程的基本操作" class="headerlink" title="进程的基本操作"></a>进程的基本操作</h1><p>以Unix系统举例： </p>
<ol>
<li> 进程的创建：fork()。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明 确的方法来分辨程序是在父进程还是在子进程中执行。 </li>
<li> 复制代码回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>复制代码加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序。<br>复制代码进程终止：</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *statusp, int options);</span><br></pre></td></tr></table></figure>

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename, const char *argv[], const char *envp[]);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>复制代码<br>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。 不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。 进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质： 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区实现。 管道的局限性： 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 特点： 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。Linux 系统上支持的30 种不同类型的信号。每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。复制代码进程在运行时有三种基本状态：就绪态、运行态和阻塞态。 2.就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 3.阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。 各状态之间的转换： 2。僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。 线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点： 引入线程就是为了解决以上进程的不足，线程具有以下的优点： 进程API以Unix系统为例，线程相关的API属于Posix线程(Pthreads)标准接口。</p>
<p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1659883620324-de53a65b-003b-4a6d-88df-e92155156f45.png"></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure>



<h1 id="进程如何通过管道进行通信"><a href="#进程如何通过管道进行通信" class="headerlink" title="进程如何通过管道进行通信"></a>进程如何通过管道进行通信</h1><ol>
<li>其本质是一个伪文件(实为内核缓冲区) </li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端。 </li>
<li>规定数据从管道的写端流入管道，从读端流出。 </li>
<li>数据自己读不能自己写。 </li>
<li>数据一旦被读走，便不在管道中存在，不可反复读取。 </li>
<li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。 </li>
<li>只能在有公共祖先的进程间使用管道。 </li>
</ol>
<h1 id="进程如何通过共享内存通信？"><a href="#进程如何通过共享内存通信？" class="headerlink" title="进程如何通过共享内存通信？"></a>进程如何通过共享内存通信？</h1><ol>
<li>共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。 </li>
<li>因为多个进程可以同时操作，所以需要进行同步处理。 </li>
<li>信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。 </li>
</ol>
<h1 id="什么是信号"><a href="#什么是信号" class="headerlink" title="什么是信号"></a>什么是信号</h1><ol>
<li>发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因： </li>
</ol>
<ul>
<li>内核检测到一个系统事件，比如除零错误或者子进程终止。 </li>
<li>—个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。 </li>
</ul>
<ol start="2">
<li>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。 </li>
</ol>
<h1 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h1><ol>
<li><p>处理程序要尽可能简单。避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查(并重置)这个标志。 </p>
</li>
<li><p>在处理程序中只调用异步信号安全的函数。所谓异步信号安全的函数(或简称安全的函数)能够被信号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号处理程序中断。 </p>
</li>
<li><p>保存和恢复errno。许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用_exit终止该进程，那么就不需要这样做了。 </p>
</li>
<li><p>阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d 时暂时阻塞信号保证了处理程序不会中断该指令序列。 </p>
</li>
<li><p>用volatile 声明全局变量。考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过，因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure></li>
<li><p>用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型sig_atomic_t对它的读和写保证会是原子的（不可中断的）。 </p>
</li>
<li><p>信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。 </p>
</li>
</ol>
<h1 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h1><ol>
<li>当前运行的进程运行结束。 </li>
<li>当前运行的进程由于某种原因阻塞。 </li>
<li>执行完系统调用等系统程序后返回用户进程。 </li>
<li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。 </li>
<li>分时系统中，分给当前进程的时间片用完。 </li>
</ol>
<h1 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h1><ol>
<li>在中断处理程序执行时。 </li>
<li>在操作系统的内核程序临界区内。 </li>
<li>其它需要完全屏蔽中断的原子操作过程中。 </li>
</ol>
<h1 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h1><ol>
<li>CPU利用率 </li>
<li>系统吞吐率，即单位时间内CPU完成的作业的数量。 </li>
<li>响应时间。 </li>
<li>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 <ul>
<li>平均周转时间 </li>
<li>带权周转时间 </li>
<li>平均带权周转时间 </li>
</ul>
</li>
</ol>
<h1 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h1><ol>
<li>运行（running）态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。 </li>
<li>就绪→执行  处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。 </li>
<li>执行→就绪  处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。 </li>
<li>执行→阻塞  正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。 </li>
<li>阻塞→就绪  处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。 </li>
</ol>
<h1 id="什么是孤儿进程？僵尸进程"><a href="#什么是孤儿进程？僵尸进程" class="headerlink" title="什么是孤儿进程？僵尸进程?"></a>什么是孤儿进程？僵尸进程?</h1><p>孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。 </p>
<h1 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h1><ol>
<li>是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保证程序的实时性，实现进程内部的并发。 </li>
<li>线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。 </li>
<li>每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 </li>
</ol>
<h1 id="为什么需要线程？"><a href="#为什么需要线程？" class="headerlink" title="为什么需要线程？"></a>为什么需要线程？</h1><ol>
<li>进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。 </li>
<li>进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。 </li>
<li>从资源上来讲，开辟一个线程所需要的资源要远小于一个进程。 </li>
<li>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间（这种时间的差异主要由于缓存的大量未命中导致）。 </li>
<li>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。 </li>
</ol>
<h1 id="简述线程和进程的区别和联系"><a href="#简述线程和进程的区别和联系" class="headerlink" title="简述线程和进程的区别和联系"></a>简述线程和进程的区别和联系</h1><ol>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 </li>
<li>进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） </li>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位。 </li>
<li>通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。 </li>
<li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 </li>
<li>进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。 </li>
<li>进程适应于多核、多机分布；线程适用于多核。 </li>
</ol>
<h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><ol>
<li>多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。 </li>
<li>一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。 </li>
<li>多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。 </li>
</ol>
<h1 id="如何解决死锁问题？"><a href="#如何解决死锁问题？" class="headerlink" title="如何解决死锁问题？"></a>如何解决死锁问题？</h1><ol>
<li>资源一次性分配，这样就不会再有请求了（破坏请求条件）。 </li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。 </li>
<li>可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。 </li>
<li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 </li>
</ol>
<h1 id="请说一下什么是写时复制？"><a href="#请说一下什么是写时复制？" class="headerlink" title="请说一下什么是写时复制？"></a>请说一下什么是写时复制？</h1><ul>
<li>如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。 </li>
<li>算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。 </li>
<li>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork()调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。 </li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/05/22/Spring/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Spring</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-item">计算机网络</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "2022c75966801d8e1d0032871703c0bb",
            repo: "winkygranger.github.io",
            owner: "WinkyGranger",
            clientID: "8bf6ad6d7398a1f67aa5",
            clientSecret: "f07834449dda641b82428622432b27a976fa9172",
            admin: ["WinkyGranger"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Winky Granger"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Winky Granger</p><p class="is-size-6 is-block">一个小开发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/WinkyGranger" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CTF/"><span class="level-start"><span class="level-item">CTF</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Java基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">Java安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">后端开发</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">安全工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CTF%E7%AE%80%E4%BB%8B/"><span class="tag">CTF简介</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JUC/"><span class="tag">JUC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><span class="tag">Java反序列化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nmap/"><span class="tag">nmap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E6%B3%A8%E5%85%A5/"><span class="tag">sql注入</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"><span class="tag">信息收集</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3/"><span class="tag">口令破解</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="tag">消息队列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#进程、线程、协程"><span class="level-left"><span class="level-item">1</span><span class="level-item">进程、线程、协程</span></span></a></li><li><a class="level is-mobile" href="#操作系统运行机制"><span class="level-left"><span class="level-item">2</span><span class="level-item">操作系统运行机制</span></span></a></li><li><a class="level is-mobile" href="#操作系统"><span class="level-left"><span class="level-item">3</span><span class="level-item">操作系统</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#进程的状态"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">进程的状态</span></span></a></li><li><a class="level is-mobile" href="#进程间通信"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">进程间通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#共享存储：共享空间对于多个进程访问是互斥的"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">共享存储：共享空间对于多个进程访问是互斥的</span></span></a></li><li><a class="level is-mobile" href="#管道通信：没写满的时候是不允许读的，没读完也是不允许写的。"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">管道通信：没写满的时候是不允许读的，没读完也是不允许写的。</span></span></a></li><li><a class="level is-mobile" href="#消息队列：消息头里包含了传递信息，不会传错给别的进程"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">消息队列：消息头里包含了传递信息，不会传错给别的进程</span></span></a></li><li><a class="level is-mobile" href="#信号"><span class="level-left"><span class="level-item">3.2.4</span><span class="level-item">信号</span></span></a></li><li><a class="level is-mobile" href="#套接字-socket"><span class="level-left"><span class="level-item">3.2.5</span><span class="level-item">套接字 socket</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#线程"><span class="level-left"><span class="level-item">4</span><span class="level-item">线程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#线程的实现方式（用户级线程、内核级线程、组合方式）"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">线程的实现方式（用户级线程、内核级线程、组合方式）</span></span></a></li><li><a class="level is-mobile" href="#多线程模型：多对一、一对多"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">多线程模型：多对一、一对多</span></span></a></li></ul></li><li><a class="level is-mobile" href="#处理机调度（线程调度）"><span class="level-left"><span class="level-item">5</span><span class="level-item">处理机调度（线程调度）</span></span></a></li><li><a class="level is-mobile" href="#进程同步"><span class="level-left"><span class="level-item">6</span><span class="level-item">进程同步</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#进程互斥"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">进程互斥</span></span></a></li><li><a class="level is-mobile" href="#临界区冲突"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">临界区冲突</span></span></a></li></ul></li><li><a class="level is-mobile" href="#死锁"><span class="level-left"><span class="level-item">7</span><span class="level-item">死锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#预防死锁"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">预防死锁</span></span></a></li><li><a class="level is-mobile" href="#避免死锁（银行家算法）"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">避免死锁（银行家算法）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存"><span class="level-left"><span class="level-item">8</span><span class="level-item">内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存管理"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">内存管理</span></span></a></li><li><a class="level is-mobile" href="#覆盖技术"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">覆盖技术</span></span></a></li><li><a class="level is-mobile" href="#交换技术"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">交换技术</span></span></a></li><li><a class="level is-mobile" href="#内存分配"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">内存分配</span></span></a></li><li><a class="level is-mobile" href="#管理方式（单一连续分配、固定分区分配方式"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">管理方式（单一连续分配、固定分区分配方式)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分页"><span class="level-left"><span class="level-item">9</span><span class="level-item">分页</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#页表"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">页表</span></span></a></li></ul></li><li><a class="level is-mobile" href="#虚拟内存"><span class="level-left"><span class="level-item">10</span><span class="level-item">虚拟内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#传统存储"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">传统存储</span></span></a></li></ul></li><li><a class="level is-mobile" href="#实现虚拟内存的技术"><span class="level-left"><span class="level-item">11</span><span class="level-item">实现虚拟内存的技术</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#请求分页存储管理"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">请求分页存储管理</span></span></a></li><li><a class="level is-mobile" href="#内存有空闲的情况"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">内存有空闲的情况</span></span></a></li><li><a class="level is-mobile" href="#内存没空闲的情况"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">内存没空闲的情况</span></span></a></li><li><a class="level is-mobile" href="#请求分段存储管理"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">请求分段存储管理</span></span></a></li><li><a class="level is-mobile" href="#请求段页式存储管理"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">请求段页式存储管理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#页面替换算法"><span class="level-left"><span class="level-item">12</span><span class="level-item">页面替换算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#最佳置换算法（OPT）"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">最佳置换算法（OPT）</span></span></a></li><li><a class="level is-mobile" href="#先进先出置换算法（FIFO）"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">先进先出置换算法（FIFO）</span></span></a></li><li><a class="level is-mobile" href="#最近最久未使用置换算法（LRU）"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">最近最久未使用置换算法（LRU）</span></span></a></li><li><a class="level is-mobile" href="#时钟置换算法（CLOCK）"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">时钟置换算法（CLOCK）</span></span></a></li><li><a class="level is-mobile" href="#改造型的时钟置换算法"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">改造型的时钟置换算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#磁盘结构"><span class="level-left"><span class="level-item">13</span><span class="level-item">磁盘结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#活动头磁盘、固定头磁盘"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">活动头磁盘、固定头磁盘</span></span></a></li><li><a class="level is-mobile" href="#写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）</span></span></a></li><li><a class="level is-mobile" href="#磁盘调度算法"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">磁盘调度算法</span></span></a></li><li><a class="level is-mobile" href="#先来先服务"><span class="level-left"><span class="level-item">13.4</span><span class="level-item">先来先服务</span></span></a></li><li><a class="level is-mobile" href="#最短寻找时间优先"><span class="level-left"><span class="level-item">13.5</span><span class="level-item">最短寻找时间优先</span></span></a></li><li><a class="level is-mobile" href="#扫描算法"><span class="level-left"><span class="level-item">13.6</span><span class="level-item">扫描算法</span></span></a></li><li><a class="level is-mobile" href="#LOOK调度算法（扫描算法改进）"><span class="level-left"><span class="level-item">13.7</span><span class="level-item">LOOK调度算法（扫描算法改进）</span></span></a></li><li><a class="level is-mobile" href="#循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均"><span class="level-left"><span class="level-item">13.8</span><span class="level-item">循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均</span></span></a></li><li><a class="level is-mobile" href="#C-LOOK调度算法"><span class="level-left"><span class="level-item">13.9</span><span class="level-item">C-LOOK调度算法</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">13.10</span><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#减少磁盘延迟时间的方法"><span class="level-left"><span class="level-item">13.11</span><span class="level-item">减少磁盘延迟时间的方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题"><span class="level-left"><span class="level-item">13.11.1</span><span class="level-item">交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题</span></span></a></li><li><a class="level is-mobile" href="#错位命名"><span class="level-left"><span class="level-item">13.11.2</span><span class="level-item">错位命名</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#IO"><span class="level-left"><span class="level-item">14</span><span class="level-item">IO</span></span></a></li><li><a class="level is-mobile" href="#select-poll-epoll"><span class="level-left"><span class="level-item">15</span><span class="level-item">select poll epoll</span></span></a></li><li><a class="level is-mobile" href="#什么是操作系统？请简要概述一下"><span class="level-left"><span class="level-item">16</span><span class="level-item">什么是操作系统？请简要概述一下</span></span></a></li><li><a class="level is-mobile" href="#操作系统有哪些分类？"><span class="level-left"><span class="level-item">17</span><span class="level-item">操作系统有哪些分类？</span></span></a></li><li><a class="level is-mobile" href="#什么是内核态和用户态？"><span class="level-left"><span class="level-item">18</span><span class="level-item">什么是内核态和用户态？</span></span></a></li><li><a class="level is-mobile" href="#如何实现内核态和用户态的切换？"><span class="level-left"><span class="level-item">19</span><span class="level-item">如何实现内核态和用户态的切换？</span></span></a></li><li><a class="level is-mobile" href="#并发和并行的区别"><span class="level-left"><span class="level-item">20</span><span class="level-item">并发和并行的区别</span></span></a></li><li><a class="level is-mobile" href="#什么是进程？"><span class="level-left"><span class="level-item">21</span><span class="level-item">什么是进程？</span></span></a></li><li><a class="level is-mobile" href="#进程的基本操作"><span class="level-left"><span class="level-item">22</span><span class="level-item">进程的基本操作</span></span></a></li><li><a class="level is-mobile" href="#进程如何通过管道进行通信"><span class="level-left"><span class="level-item">23</span><span class="level-item">进程如何通过管道进行通信</span></span></a></li><li><a class="level is-mobile" href="#进程如何通过共享内存通信？"><span class="level-left"><span class="level-item">24</span><span class="level-item">进程如何通过共享内存通信？</span></span></a></li><li><a class="level is-mobile" href="#什么是信号"><span class="level-left"><span class="level-item">25</span><span class="level-item">什么是信号</span></span></a></li><li><a class="level is-mobile" href="#如何编写正确且安全的信号处理函数"><span class="level-left"><span class="level-item">26</span><span class="level-item">如何编写正确且安全的信号处理函数</span></span></a></li><li><a class="level is-mobile" href="#进程调度的时机"><span class="level-left"><span class="level-item">27</span><span class="level-item">进程调度的时机</span></span></a></li><li><a class="level is-mobile" href="#不能进行进程调度的情况"><span class="level-left"><span class="level-item">28</span><span class="level-item">不能进行进程调度的情况</span></span></a></li><li><a class="level is-mobile" href="#进程调度策略的基本设计指标"><span class="level-left"><span class="level-item">29</span><span class="level-item">进程调度策略的基本设计指标</span></span></a></li><li><a class="level is-mobile" href="#进程的状态与状态转换"><span class="level-left"><span class="level-item">30</span><span class="level-item">进程的状态与状态转换</span></span></a></li><li><a class="level is-mobile" href="#什么是孤儿进程？僵尸进程"><span class="level-left"><span class="level-item">31</span><span class="level-item">什么是孤儿进程？僵尸进程?</span></span></a></li><li><a class="level is-mobile" href="#什么是线程？"><span class="level-left"><span class="level-item">32</span><span class="level-item">什么是线程？</span></span></a></li><li><a class="level is-mobile" href="#为什么需要线程？"><span class="level-left"><span class="level-item">33</span><span class="level-item">为什么需要线程？</span></span></a></li><li><a class="level is-mobile" href="#简述线程和进程的区别和联系"><span class="level-left"><span class="level-item">34</span><span class="level-item">简述线程和进程的区别和联系</span></span></a></li><li><a class="level is-mobile" href="#多线程模型"><span class="level-left"><span class="level-item">35</span><span class="level-item">多线程模型</span></span></a></li><li><a class="level is-mobile" href="#如何解决死锁问题？"><span class="level-left"><span class="level-item">36</span><span class="level-item">如何解决死锁问题？</span></span></a></li><li><a class="level is-mobile" href="#请说一下什么是写时复制？"><span class="level-left"><span class="level-item">37</span><span class="level-item">请说一下什么是写时复制？</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Winky&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Winky</span>   当一个人的征途是星辰大海时，长路漫漫间，虽寂静，但永不孤独……</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/WinkyGranger"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>