<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    MySQL |
    
    Winky&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Winky's Blog" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-Mysql" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    MySQL
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/20/Mysql/" class="article-date">
  <time datetime="2022-05-20T13:03:41.000Z" itemprop="datePublished">2022-05-20</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/java/">java</a> / <a class="article-category-link" href="/categories/java/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h1 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h1><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的</p>
<h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<br>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。<br>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND</p>
<h2 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h2><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方面后面模块获取 SQL 类型、表名、字段名、 where 条件等等。<br>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>我们先来说说预处理阶段做了什么事情。</p>
<ul>
<li>检查 SQL 查询语句中的表或者字段是否存在；</li>
<li>将 select * 中的 * 符号，扩展为表上的所有列<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</li>
</ul>
<p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<ul>
<li><p>逻辑优化查询：怎么查询效率更高</p>
</li>
<li><p>物理优化查询：索引等</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。<br>接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。</p>
</li>
<li><p>主键索引查询</p>
</li>
<li><p>全表扫描</p>
</li>
<li><p>索引下推</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行一条 SQL 查询语句，期间发生了什么？</p>
</li>
<li><p>连接器：建立连接，管理连接、校验用户身份；</p>
</li>
<li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p>
</li>
<li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p>
</li>
<li><p>执行 SQL：执行 SQL 共有三个阶段：</p>
<ul>
<li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333914716-af5bc129-39a9-4b31-8c80-e0ee9d39f500.png#averageHue=%23f2eee8&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uda63ecc3&margin=%5Bobject%20Object%5D&originHeight=721&originWidth=1261&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u34333de7-b2ac-425f-b7d7-94b9014ee47&title="></p>
<h1 id="Mysql-explain-执行计划"><a href="#Mysql-explain-执行计划" class="headerlink" title="Mysql explain 执行计划"></a>Mysql explain 执行计划</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1658305376551-ad5553c7-9e4e-4e53-9ec2-c0f9739a1783.png#averageHue=%23faf9f8&clientId=u2af9f06b-6500-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=177&id=u947cd4cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=909&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38949&status=done&style=none&taskId=u2cecd7c2-0ddf-49fa-9ee1-8c0589c8ac2&title=&width=808" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1658305387675-47f134db-f45f-4722-b9a0-1a88d5de0cf6.png#averageHue=%23faf8f5&clientId=u2af9f06b-6500-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=636&id=u2ba8c273&margin=%5Bobject%20Object%5D&name=image.png&originHeight=715&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&size=312776&status=done&style=none&taskId=uc94e0302-04a5-4e44-8c7c-57f404b0a13&title=&width=852.4444444444445" alt="image.png"></p>
<h1 id="事务的四大特性？"><a href="#事务的四大特性？" class="headerlink" title="事务的四大特性？"></a>事务的四大特性？</h1><p><strong>事务特性ACID</strong>：<strong>原子性</strong>（<code>Atomicity</code>）、<strong>一致性</strong>（<code>Consistency</code>）、<strong>隔离性</strong>（<code>Isolation</code>）、<strong>持久性</strong>（<code>Durability</code>）。</p>
<ul>
<li><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。</li>
<li><strong>隔离性</strong>。跟隔离级别相关，如<code>read committed</code>，一个事务只能读到已经提交的修改。</li>
<li><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1></li>
</ul>
<p><strong>一范式、二范式、三范式、巴斯-科德范式、第四范式、第五范式（完美范式）</strong><br><strong>「第一范式」</strong>：数据库中的字段具有<strong>「原子性」</strong>，不可再分，并且是单一职责</p>
<table>
<thead>
<tr>
<th><strong>国家</strong></th>
<th><strong>省</strong></th>
<th><strong>市</strong></th>
<th><strong>区</strong></th>
<th><strong>街道</strong></th>
</tr>
</thead>
<tbody><tr>
<td>中国</td>
<td>上海</td>
<td>上海</td>
<td>宝山区</td>
<td>上大路99号</td>
</tr>
</tbody></table>
<p><strong>「第二范式」</strong>：<strong>「建立在第一范式的基础上」</strong>，第二范式要求数据库表中的每个实例或行必须<strong>「可以被唯一地区分」</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键。（任何字段只能依赖主键）</p>
<table>
<thead>
<tr>
<th><strong>订单编号</strong></th>
<th><strong>商品编号</strong></th>
<th><strong>用户ID</strong></th>
<th><strong>下单时间</strong></th>
<th><strong>商品名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td>4654641666</td>
<td>4553</td>
<td>2424</td>
<td>2022-07-04</td>
<td>洗衣机</td>
</tr>
</tbody></table>
<p>很显然，商品名称和订单无关，商品名称是依赖商品编号的，这是<strong>部分依赖</strong>！不应该放在同一张表格里面，应该拆成订单表和商品表。<br><strong>「第三范式」</strong>：<strong>「建立在第一，第二范式的基础上」</strong>，确保每列都和主键列直接相关，而不是间接相关不存在其他表的非主键信息<br>其中总价是通过前面两个字段计算得到，数据库不要有数学计算的操作，业务需要的时候通过代码进行计算，不要入库</p>
<table>
<thead>
<tr>
<th><strong>商品</strong></th>
<th><strong>单价</strong></th>
<th><strong>数量</strong></th>
<th><strong>总价</strong></th>
</tr>
</thead>
<tbody><tr>
<td>12456</td>
<td>10</td>
<td>50</td>
<td>500</td>
</tr>
</tbody></table>
<p>但是在我们的日常开发当中，<strong>「并不是所有的表一定要满足三大范式」</strong>，有时候冗余几个字段可以少关联几张表，带来的查询效率的提升有可能是质变的</p>
<h1 id="Order-By-为什么会导致索引失效"><a href="#Order-By-为什么会导致索引失效" class="headerlink" title="Order By 为什么会导致索引失效"></a>Order By 为什么会导致索引失效</h1><ul>
<li><p>字段： a\b\c\d,索引：b\c\d</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c,d;</span><br></pre></td></tr></table></figure>

<ul>
<li>走bcd，不需要排序，n次回表</li>
<li>全表扫描，内存里排库 + 不用回表<h1 id="MySQL锁的类型"><a href="#MySQL锁的类型" class="headerlink" title="MySQL锁的类型"></a>MySQL锁的类型</h1></li>
</ul>
</li>
<li><p>基于锁的分类：共享锁、排他锁</p>
</li>
<li><p>基于锁的粒度：行级锁、表级锁、页级锁、记录锁、间隙锁、临键锁</p>
</li>
<li><p>基于锁的状态：意向共享锁、意向排他锁</p>
<h2 id="表级锁具体内容"><a href="#表级锁具体内容" class="headerlink" title="表级锁具体内容"></a>表级锁具体内容</h2></li>
<li><p>表锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock tables 表名…… read<span class="operator">/</span>write</span><br><span class="line"></span><br><span class="line">lock tables </span><br></pre></td></tr></table></figure>

<ul>
<li>表共享读锁</li>
<li>表独占写锁</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333063981-ebe95b29-107d-44e3-a5cc-11068f72dcba.png#averageHue=%23faf8f8&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u040e3ad1&margin=%5Bobject%20Object%5D&name=image-20220520223417654.png&originHeight=378&originWidth=624&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90321&status=done&style=none&taskId=u566585b9-3435-45f5-acdc-82f86af2bc7&title=" alt="image-20220520223417654.png"></li>
</ul>
</li>
<li><p>元数据锁（共享锁）：在select和update时候都会自动加上</p>
<ul>
<li>系统自动，无需显示使用，访问一张表会自动加上。当这张表上有未提交的事物，就不能修改表结构，被阻塞</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333113221-e980c641-94a1-41cb-afc3-8d561267e904.png#averageHue=%23dfc2be&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uada987dd&margin=%5Bobject%20Object%5D&name=image-20220520224315911.png&originHeight=144&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53834&status=done&style=none&taskId=ub6088401-d761-4d5d-bc59-7ed1c601a2b&title=" alt="image-20220520224315911.png"></li>
</ul>
</li>
<li><p>意向锁</p>
<ul>
<li>一个线程A给一行加了锁。另一个线程B想给整张表加锁，此时会有问题，B就要一帮一行找A给哪一行加了锁，很麻烦。</li>
<li>修改：在A给表加行锁的时候还会有一把意向锁，B要给表上锁的时候就会和意向锁进行兼容，兼容就说明可以给表上锁，否则不行，会处于阻塞状态，直到A行锁释放意向锁释放，B给表上锁</li>
<li>意向锁分为两种：意向共享锁和意向排他锁<ul>
<li>意向共享锁：与表锁共享锁兼容，与表锁排他锁互斥</li>
<li>意向排他锁：与表锁共享锁、表锁排他锁互斥<h2 id="行级锁具体内容"><a href="#行级锁具体内容" class="headerlink" title="行级锁具体内容"></a>行级锁具体内容</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>行锁</p>
<ul>
<li>共享锁：</li>
<li>排他锁：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333133166-f8db6502-9f48-45ea-920c-c05a2a3b96dd.png#averageHue=%23ddb1ab&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc1624c28&margin=%5Bobject%20Object%5D&name=image-20220520232600766.png&originHeight=161&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30024&status=done&style=none&taskId=uf200cd15-dfda-466d-8b2f-c774f4c864a&title=" alt="image-20220520232600766.png"></li>
</ul>
</li>
<li><p>间隙锁（一个范围，不包含该记录），确保索引间隙不变，防止其他事务在这个间隙进行insert导致幻读</p>
</li>
<li><p>临键锁：行锁+间隙锁，同时锁住数据和间隙</p>
<h1 id="MySQL数据库中什么情况下索引无法使用"><a href="#MySQL数据库中什么情况下索引无法使用" class="headerlink" title="MySQL数据库中什么情况下索引无法使用"></a>MySQL数据库中什么情况下索引无法使用</h1></li>
<li><p>不符合最左匹配原则</p>
</li>
<li><p>字段进行了隐私数据类型转化</p>
</li>
<li><p>走索引没有全表扫描效率高</p>
<h1 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h1></li>
<li><p>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</p>
</li>
<li><p>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</p>
</li>
<li><p>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<h1 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h1><table>
<thead>
<tr>
<th><strong>myISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td>不支持事务，每次查询都是原子的</td>
<td>ACID，事务，支持四种隔离级别</td>
</tr>
<tr>
<td>表锁</td>
<td>行锁，支持并发写</td>
</tr>
<tr>
<td>无MVCC</td>
<td>MVCC</td>
</tr>
<tr>
<td>三个文件：索引文件、表结构文件、数据文件</td>
<td>除了主键以外，其他索引只存储索引内容</td>
</tr>
<tr>
<td>存储了表的总行数</td>
<td>没有存表行数</td>
</tr>
<tr>
<td>索引数据分开</td>
<td>主键索引文件存了所有的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<p>注意：MyISAM引擎的主键索引，B+数的叶子节点存储的是主键和</p>
<h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><ul>
<li><p>MVCC 多版本并发控制，读取的时候通过快照的方式将数据存下来，这样读锁写锁不冲突，不同事物session会看到自己的版本链</p>
</li>
<li><p>MVCC只在已提交读和可重复读两个隔离级别下工作</p>
</li>
<li><p>InnoDB在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录回滚的版本号。</p>
</li>
<li><p>聚簇索引记录中有3个隐藏列 trx_id 和roll_pointer和ROW_ID</p>
<ul>
<li>trx_id：用来存储每一次对某条聚簇索引记录修改时的事务id</li>
<li>roll_pointer：修改时，将老版本写入undo log中，roll_pointer存了一个指针，指向上一个版本记录的位置，通过它来获得上一条记录的信息</li>
<li>ROW_ID：隐藏主键，如果表结构没有指定主键，将会生成隐藏字段</li>
</ul>
</li>
<li><p>已提交读和可重复读的区别在于他们生成的ReadView策略不同</p>
<ul>
<li>开始事务时创建ReadView，维护事务的id（即未提交的事务），排成一个数组</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333223780-4c02d9c3-5164-4eee-a728-213900de5c01.png#averageHue=%23f7f7f7&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u89562f65&margin=%5Bobject%20Object%5D&name=image-20220509110016131.png&originHeight=191&originWidth=653&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15489&status=done&style=none&taskId=u76b3800c-7c2b-4cc3-9364-e7abca2150b&title=" alt="image-20220509110016131.png"><ul>
<li>已提交读：事务每次查询开始都声称一个独立的ReadView</li>
<li>可重复读：第一次读的时候生成一个ReadView，之后复用之前的ReadView</li>
</ul>
</li>
</ul>
</li>
<li><p>通过版本链实现并发读写。通过ReadView生成策略的不同实现不同的隔离级别</p>
<h1 id="什么是脏读、幻读、不可重复读"><a href="#什么是脏读、幻读、不可重复读" class="headerlink" title="什么是脏读、幻读、不可重复读"></a>什么是脏读、幻读、不可重复读</h1></li>
<li><p>脏读：一个事务修改了一个值，但是需要回滚 回滚前另一个事务读到了被修改后的值</p>
</li>
<li><p>幻读：一个事务插入了一条数据。插入前后另一个事务分别读取，读取的记录数不一样</p>
</li>
<li><p>不可重复读：一个事务修改前后，另一个事务读到的数据不一致</p>
<h1 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h1></li>
<li><p>ACID</p>
<ul>
<li>原子性：全执行/不执行</li>
<li>一致性：</li>
<li>隔离性：事务事物之间互不干扰</li>
<li>持久性：写在磁盘</li>
</ul>
</li>
<li><p>隔离级别</p>
<ul>
<li>读未提交：脏读 幻读 不可重复读</li>
<li>读已提交：幻读 不可重复读</li>
<li>可重复读：幻读(可通过临键锁解决)</li>
<li>串行化：（大量的锁 容易导致死锁）<h1 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h1>事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。<br>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。<br>每当有修改事务时，还会产生undo log，如果需要回滚，则根据undo log 的反向语句进行逻辑操作，比如insert一条记录就delete一条记录。undo log主要实现数据库的一致性。</li>
</ul>
</li>
</ul>
<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ul>
<li>功能逻辑上：普通索引、唯一索引、全文索引、单列索引</li>
<li>物理实现：聚簇索引、非聚簇索引</li>
<li>作用字段个数：单列索引、联合索引</li>
</ul>
<p><strong>普通索引：</strong>可以在任何数据类型<br><strong>唯一索引：</strong>该值必须唯一，允许有空值，比如邮箱、身份证、手机号<br><strong>主键索引：</strong>聚簇索引、非聚簇索引<br><strong>单列索引：</strong>一个字段<br><strong>联合索引：</strong>idx_id_name_gender 多个字段，使用要遵守<strong>最左前缀原则</strong></p>
<h1 id="什么是索引覆盖"><a href="#什么是索引覆盖" class="headerlink" title="什么是索引覆盖"></a>什么是索引覆盖</h1><p>SQL执行的时候可以利用索引快速查找。字段在索引中都包含了，不需要回表，所有数据都在叶子节点上.</p>
<ul>
<li>理解方式1：索引是高校找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此他不必读取整个行，毕竟索引叶子节点储存了他们的索引数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了，<strong>一个索引包含了满足查询结果的所有数据就叫组覆盖索引</strong></li>
<li>理解方式2：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN、WHERE子句中做到所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）</li>
</ul>
<p>简单地说就是：索引列+主键 包含SELECT到FROM之间的查询列</p>
<h1 id="聚集索引、非聚集索引"><a href="#聚集索引、非聚集索引" class="headerlink" title="聚集索引、非聚集索引"></a>聚集索引、非聚集索引</h1><ul>
<li><p>InnoDB中，主键索引和每一条数据都放在同一个文件中。聚集索引的叶子节点包含了完整的数据记录</p>
</li>
<li><p>MyISAM的索引和主键分别放在myi和myd中，每次查询的时候从myi查到数据的存放位置，然后去myd中查出来，类似于一种回表的操作</p>
<h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h2><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p>
</li>
<li><p>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</p>
</li>
<li><p>二级索引的叶子节点存放的是主键值，而不是实际数据。</p>
</li>
</ul>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。<br>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li>
</ul>
<p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。<br>二级索引的 B+ 树如下图，数据部分为主键值：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657334316183-212c9bda-c218-41a8-972d-ca65855f7155.png#averageHue=%23f8f1e9&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua6c5e8d6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=97395&status=done&style=none&taskId=u1965a9e1-deb9-4dcf-bd97-0e0e36a792f&title=" alt="image.png"><br>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p>
<h1 id="MySQL三大日志-binlog、redo-log和undo-log-详解"><a href="#MySQL三大日志-binlog、redo-log和undo-log-详解" class="headerlink" title="MySQL三大日志(binlog、redo log和undo log)详解"></a>MySQL三大日志(binlog、redo log和undo log)详解</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333329885-3b7fdef7-9a04-4283-a545-d62272fa75c7.png#averageHue=%23999b98&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u12a38d1a&margin=%5Bobject%20Object%5D&name=image-20220613161321165.png&originHeight=236&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65469&status=done&style=none&taskId=ud265d115-b908-46ab-a15e-74dc19c3f38&title=" alt="image-20220613161321165.png"></p>
<ul>
<li>redo log:（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。<ul>
<li>比如 MySQL 实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。</li>
<li>MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。</li>
<li>后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</li>
<li>更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。</li>
<li><strong>然后会把“在某个数据页上做了什么修改，比如页号xxx,偏移量yyy，写入了zzz数据”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</strong>（物理级别的修改）</li>
</ul>
</li>
<li>binlog<ul>
<li>redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。</li>
<li>而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</li>
<li>在事务执行的过程中，redo log会不断顺序记录，直到这个给事务提交，才会一次性写到bin log 中。</li>
</ul>
</li>
<li>undo log<ul>
<li>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</li>
<li>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</li>
</ul>
</li>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。<h1 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h1></li>
</ul>
<p><strong>(1)</strong> 为什么要做主从复制？<br>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。<br>2、做数据的热备<br>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。<br><strong>(2)</strong> 什么是mysql的主从复制<br>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用<strong>异步</strong>复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。<br><strong>(3)</strong> 主从复制原理</p>
<ol>
<li>master服务器将数据的改变记录在二进制binlog日志上，当master上的数据发生改变时，将其写入二进制文件中;</li>
<li>slave服务器会在一定时间间隔内对master二进制日志进行探测是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件</li>
<li>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制时间，并保存至 从节点 本地的中继日志中，从节点 将启动sql线程从中继日志中读取二进制日志，在本地释放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</li>
</ol>
<p>简单说：</p>
<ul>
<li><p>从库会生成两个线程,一个I/O线程,一个SQL线程;</p>
</li>
<li><p>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</p>
</li>
<li><p>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</p>
</li>
<li><p>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行。</p>
<h1 id="Innodb如何实现事务（update语句为例）"><a href="#Innodb如何实现事务（update语句为例）" class="headerlink" title="Innodb如何实现事务（update语句为例）"></a>Innodb如何实现事务（update语句为例）</h1></li>
<li><p>Buffer Pool: update语句—&gt; 找到数据所在页-&gt; 缓存在Buffer Pool中</p>
</li>
<li><p>执行update语句 修改Buffer pool中的数据</p>
</li>
<li><p>针对update语句生成redolog对象，存入logBuffer中</p>
</li>
<li><p>针对update语句生成undo日志作为回滚使用</p>
</li>
<li><p>如果事务提交，Redolog持久化，后续有机制将BufferPool 中所修改的数据页持久化到磁盘中</p>
</li>
<li><p>如果事务回滚，则用undo日志进行回滚</p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1659944815452-bf46871a-de0e-4118-b912-69b3a44f67c7.png#averageHue=%23f0f0df&clientId=u6df81462-1dfc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf18b65c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1068&originWidth=1090&originalType=url&ratio=1&rotation=0&showTitle=false&size=808043&status=done&style=none&taskId=uf3a17778-a0ef-4a90-ac84-08c1ca33665&title=" alt="image.png"></p>
<h1 id="Innodb-事务为什么要两阶段提交"><a href="#Innodb-事务为什么要两阶段提交" class="headerlink" title="Innodb 事务为什么要两阶段提交?"></a>Innodb 事务为什么要两阶段提交?</h1></li>
<li><p>两段式提交，就是我们先把这次更新写入到redolog中，并设redolog为prepare状态，然后再写入binlog,写完binlog之后再提交事务，并设redolog为commit状态。也就是把redolog拆成了prepare和commit两段！</p>
</li>
<li><p>其实redolog是后来才加上的，binlog是之前就有的。一开始存储引擎只有MyISAM,后来才有的InnoDB,然后MyISAM没有事务，没有crash-safe的能力。所以InnoDB搞了个redolog。然后<strong>为了保证两份日志同步，所以才有了两段式提交</strong>。</p>
</li>
<li><p>你假设一下如果先保存好redolog,然后再记录binlog。如果redolog写好了之后挂了。ok你看起来好像是没问题了，但是你的binlog还没记录，所以这条记录就少了！如果你备份这份binlog之后，你这条记录就永远的少了！</p>
</li>
<li><p>那如果先写binlog再写redolog呢？那binlog写完了，你数据库挂了，那redolog是不是没有，没有的意思就是你以前你没更新成功。但是binlog已经记录好了，在它那边反正是成功了，所以那备份的binlog也不对！</p>
<h1 id="WAl-是什么-有什么好处"><a href="#WAl-是什么-有什么好处" class="headerlink" title="WAl 是什么?有什么好处?"></a>WAl 是什么?有什么好处?</h1><p>WAI主要先写日志、再写磁盘</p>
</li>
</ul>
<p><strong>WAL(Write Ahead Log)预写日志，是数据库系统中常见的一种手段，用于：</strong><br>1、保证数据操作的原子性和持久性。<br>2、使得随机写变为顺序写提高性能。<br><strong>WAL 的优点：</strong></p>
<ol>
<li>读和写可以完全地并发执行，不会互相阻塞（但是写之间仍然不能并发）。</li>
<li>WAL 在大多数情况下，拥有更好的性能（因为无需每次写入时都要写两个文件）。</li>
<li>磁盘 I/O 行为更容易被预测。</li>
<li>使用更少的 fsync()操作，减少系统脆弱的问题。<h1 id="什么是索引下推-INDEX-CONDITION-PUSHDOWN"><a href="#什么是索引下推-INDEX-CONDITION-PUSHDOWN" class="headerlink" title="什么是索引下推? INDEX CONDITION PUSHDOWN"></a>什么是索引下推? INDEX CONDITION PUSHDOWN</h1>索引下推是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。<br>例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> S1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>对于我们理解的而言，查询的顺序应该是：<ul>
<li>先找到 key1 &gt; ‘z’的行，然后回表查询，最后筛选key1 LIKE ‘%a’的数据返回</li>
</ul>
</li>
<li>但是对于查询优化器而言：<ul>
<li>先找到 key1 &gt; ‘z’的行，这个时候先不回表，继续执行key1 LIKE ‘%a’，直接在索引中挑选出来，最后把符合这两个条件的数据进行回表查找。此时减少了回表的次数</li>
</ul>
</li>
</ul>
<p>例如：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333401038-cf3aa45a-aacc-40da-a002-3aa628617fdb.png#averageHue=%23f6f1e8&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0b9f2241&margin=%5Bobject%20Object%5D&name=image-20220612210116273.png&originHeight=186&originWidth=370&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75911&status=done&style=none&taskId=ud6fa5de9-5f15-4f81-bb51-408da160276&title=" alt="image-20220612210116273.png"><br>索引为zipcode,lastname,address 联合索引</p>
<ul>
<li>索引中包含了后面查询田中的字段，在回表前索引下推机制是会先做判断的<h1 id="一条-Sql-语句查询偶尔慢会是什么原因"><a href="#一条-Sql-语句查询偶尔慢会是什么原因" class="headerlink" title="一条 Sql 语句查询偶尔慢会是什么原因?"></a>一条 Sql 语句查询偶尔慢会是什么原因?</h1></li>
</ul>
<ol>
<li><strong>数据库刷新脏页</strong>当我们要往数据库中插入一条数据或者更新一条数据时，数据库会在内存中把对应字段的数据更新了，但是更新完毕之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到redo log日志中去，只有等到空闲的时候才会通过redo log里的日志把最新的数据同步到磁盘里。这里redo log的容量是有限的，所以如果数据库一直很忙且更新有很频繁，那么这个时候redo log很快就会被写满，从而没办法等到空闲时再把数据同步到磁盘，只能暂停其他操作，全身心来把数据同步到磁盘中去，造成的表象就是我们平时正常的SQL语句突然会执行的很慢。<strong>也就是说，数据库在同步数据到磁盘的时候就有可能会导致我们的SQL语句执行的很慢。</strong></li>
<li><strong>无法获取锁资源执行的时候遇到了表锁或者行锁。</strong>如果我们要执行的SQL语句，其涉及到的表正好别人在用并且加锁了，或者表并没有加锁，但是要使用到的某一行被加锁了，那么我们便无法获取锁，只能慢慢等待别人释放锁了。如果要判断是否真的在等待锁资源，我们可以使用”show processlist”命令来查看当前的状态。<h1 id="主从延迟要怎么解决"><a href="#主从延迟要怎么解决" class="headerlink" title="主从延迟要怎么解决?"></a>主从延迟要怎么解决?</h1></li>
</ol>
<ul>
<li><p>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</p>
</li>
<li><p>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</p>
</li>
<li><p>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</p>
</li>
<li><p>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</p>
<h1 id="删除表数据后表的大小却没有变动-这是为什么"><a href="#删除表数据后表的大小却没有变动-这是为什么" class="headerlink" title="删除表数据后表的大小却没有变动,这是为什么?"></a>删除表数据后表的大小却没有变动,这是为什么?</h1><p>1、释放这些空间的操作本身就需要时间，如果每次删除数据都去进行这个操作，显然会影响性。<br>2、第二个原因则是因为表里后续还是会有新的数据插入，这些删除的数据空间可以在新的数据插入进来后重新利用即可，这样也避免了新增数据要去重新申请新的空间。</p>
<h1 id="为什么-VarChar-建议不要超过255"><a href="#为什么-VarChar-建议不要超过255" class="headerlink" title="为什么 VarChar 建议不要超过255?"></a>为什么 VarChar 建议不要超过255?</h1><p>首先VARCHAR不是定长的，而是可变的，所以一般业务开发我们都要尽量使用最小的长度来满足需求，以免浪费空间，影响性能，而既然是可变的长度，那就得有保存长度的地方，所以如果VARCHAR的长度设置在255以下，那只会使用额外一个字节来保存长度，但是如果VARCHAR的长度设置在255以上，那么就会使用额外的两个字节来保存长度，无形中就浪费了存储空间。</p>
<h1 id="Redis和MySQL如何保证数据的一致性"><a href="#Redis和MySQL如何保证数据的一致性" class="headerlink" title="Redis和MySQL如何保证数据的一致性"></a>Redis和MySQL如何保证数据的一致性</h1><p>问题：一份数据同时保存在数据库里和redis里面，数据发生变化的时候redis和MySQL变化是有先后顺序的</p>
</li>
<li><p>先更新数据库再更新缓存/先更新缓存再更新数据库</p>
<ul>
<li>一个改还没同步，另一个查 不一致</li>
</ul>
</li>
<li><p>先删除缓存再更新数据库</p>
</li>
<li><p>延时双删</p>
</li>
</ul>
<p>保证高一致性：<br>MQ手动应答确保redis删除<br>Canal组件监听binlog日志</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/20/Mysql/" data-id="cld0dkug00001ywvkfnn8gngi" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-nav-link">
    <strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">
      
      计算机网络
      
    </div>
  </a>
  
  
</nav>

  

  
  
<div class="vcomments" id="vcomments"></div>

<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  new Valine({
    el: '#vcomments',
    appId: '',
    appKey: '',
    notify: 'false',
    verify: 'true',
    avatar: 'mp',
    pageSize: '10',
    placeholder: '请输入...'
  })
</script>

  
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">


<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>


<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: [''],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>Winky&#39;s Blog &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Winky&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>