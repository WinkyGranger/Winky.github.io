<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    Winky&#39;s Blog
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Winky's Blog" type="application/atom+xml">
</head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Winky&#39;s Blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Winky&#39;s Blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-Spring" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/22/Spring/">Spring</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/22/Spring/" class="article-date">
  <time datetime="2022-05-22T13:03:41.000Z" itemprop="datePublished">2022-05-22</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/java/">java</a> / <a class="article-category-link" href="/categories/java/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="谈谈对AOP的理解"><a href="#谈谈对AOP的理解" class="headerlink" title="谈谈对AOP的理解"></a>谈谈对AOP的理解</h1><ul>
<li><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身校心功能之外，这些组件还经常承担者额外的指责。例如日志，事务管理和安全这样的核心服务经第融入到自身具有校心业务理相的组件中去。这些系统服务经第被称为横切关注点，因为它们会路越系統的多个组件。</p>
</li>
<li><p>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力，也就是说，OOP允许你定义从上到下的关系，但井不适合定义从左到右的关系，例如日志功能。</p>
</li>
<li><p>日志代码往往水平地散布在所有层次中，而与它所散布到的对象的校心功能无关系。</p>
</li>
<li><p>在OOP设计中，已导致了大量代码的重复，而不利于各个模块的重用。</p>
</li>
<li><p>AOP：将程序中的交叉业务设得(比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻得）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</p>
<h1 id="AOP有哪些实现方式"><a href="#AOP有哪些实现方式" class="headerlink" title="AOP有哪些实现方式"></a>AOP有哪些实现方式</h1><p>AOP是通过动态代理实现的，代理模式是一种设计模式，它提供了对目标对象额外的访问方式，即通过代理对象来访问目标对象，这样可以在不修改原目标对象的情况下提供额外的功能。<br>静态代理与动态代理区别：</p>
</li>
<li><p>静态代理在编译时就实现了，编译完后是一个实际的.class文件。</p>
</li>
<li><p>动态代理是运行时生成的，即编译完以后没有实际的.class文件，而是生成类字节码，并加载到jvm中。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2></li>
<li><p>指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强;</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2></li>
<li><p>在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p>
<ul>
<li>JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类<strong>必须实现一个接口</strong>。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</li>
<li>CGLIB 动态代理：如果月标类没有实现接口，那么spring AoP 会选择使用 CGLIB 来动态代理目标类。CGLIB(Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过<strong>继承的方式</strong>做的动态代理，因此如果某个类被标记为 final，那么它是无法使用CGLTB 做动态代理的。</li>
</ul>
</li>
</ul>
<h1 id="谈谈对IOC的理解"><a href="#谈谈对IOC的理解" class="headerlink" title="谈谈对IOC的理解"></a>谈谈对IOC的理解</h1><p><strong>容器概念、控制反转、依赖注入</strong></p>
<h2 id="IOC容器："><a href="#IOC容器：" class="headerlink" title="IOC容器："></a>IOC容器：</h2><ul>
<li><p>实际上就是个map (key， value），里面存的是各种对象（在xml里配置的bean节点、@repository、@service.@controller. @component)，在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里</p>
</li>
<li><p>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入 (autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref厲性根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</p>
<h2 id="控制反转："><a href="#控制反转：" class="headerlink" title="控制反转："></a>控制反转：</h2></li>
<li><p>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上</p>
</li>
<li><p>引入IOC容器之后，对象A与对象B之间失去了直接联系，<strong>当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方</strong>。通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是控制反转这个名称的由来。</p>
</li>
<li><p>全部对象的控制权全部上缴给”第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似”粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个”粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成”粘合剂”的由来。</p>
<h2 id="依赖注入："><a href="#依赖注入：" class="headerlink" title="依赖注入："></a>依赖注入：</h2></li>
<li><p>获得依赖对象的过程被反转了。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由容器在运行期间，动态地将某种依赖注入到对象之中。</p>
<h1 id="Spring加载Bean的过程"><a href="#Spring加载Bean的过程" class="headerlink" title="Spring加载Bean的过程"></a>Spring加载Bean的过程</h1><p>bean的定义信息：xml 注解<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657695101824-f4745b45-8fbd-46af-a9d5-0da9daeb15a7.jpeg"></p>
<h1 id="BeanFactory-FactoryBean区别"><a href="#BeanFactory-FactoryBean区别" class="headerlink" title="BeanFactory FactoryBean区别"></a>BeanFactory FactoryBean区别</h1><p>BeanFactory：必须遵循完整的Bean生命周期去创建对象，<strong>流水线式创建</strong>。<br>FactoryBean：创建对象但是没有标准的流程，<strong>类似私人定制</strong>。</p>
</li>
<li><p>isSingleton 判断是否单例</p>
</li>
<li><p>getObjectType 返回对象的类型</p>
</li>
<li><p>getObject 返回对象</p>
<h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h1></li>
</ul>
<p><strong>创建前准备、创建实例、依赖注入、容器缓存、销毁实例</strong></p>
<ul>
<li><p> Spring 容器 从 XML 文件中读取 bean 的定义BeanDefinition，并<strong>实例化 bean</strong>。 </p>
</li>
<li><p> Spring 根据 bean 的定义填充所有的属性（对对象中加入Autowried注解的属性进行<strong>自定义属性填充</strong>）。</p>
</li>
<li><p>调用Aware方法，如果 bean 实现了 BeanNameAware 接口，Spring 传递 bean 的 ID 到 setBeanName 方法；如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递 beanfactory 给 setBeanFactory 方法。（<strong>设置容器属性</strong>） </p>
</li>
<li><p>如果有任何与 bean 相关联的 BeanPostProcessors，Spring 会在 postProcesserBeforeInitialization()方法内调用它们。（初始化前的方法）</p>
</li>
<li><p>如果 bean 实现 IntializingBean 了，调用它的 afterPropertiesSet 方法， 如果 bean 声明了初始化方法，<strong>调用此初始化方法</strong>。 （初始化方法）</p>
</li>
<li><p>如果有 BeanPostProcessors 和 bean 关联，这些 bean 的 postProcessAfterInitialization() 方法将被调用。 （初始化后方法，这里会进行AOP）</p>
</li>
<li><p>如果当前创建的bean是单例的，把bean放入单例池</p>
</li>
<li><p>使用bean</p>
</li>
<li><p>如果 bean 实现了 DisposableBean，它将调用 destroy()方法。  </p>
<h1 id="什么是Bean的自动装配，有哪些方式"><a href="#什么是Bean的自动装配，有哪些方式" class="headerlink" title="什么是Bean的自动装配，有哪些方式"></a>什么是Bean的自动装配，有哪些方式</h1><p>Spring 容器能够自动装配相互合作的 bean，这意味着容器不需要和配置，能通 过 Bean 工厂自动处理 bean 之间的协作。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;book&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.xxx.xxx.Book&quot;</span> <span class="attr">autowrire</span> = <span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p> no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。  </p>
</li>
<li><p> byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。  </p>
</li>
<li><p> byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误，使用@Qualifire注解指定 一个去注入。</p>
</li>
<li><p> constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 </p>
</li>
<li><p>autodetect：首先尝试使用 constructor 来自动装配，如果无法工作， 则使用 byType 方式。  </p>
<h1 id="Spring中的Bean是线程安全的吗"><a href="#Spring中的Bean是线程安全的吗" class="headerlink" title="Spring中的Bean是线程安全的吗"></a>Spring中的Bean是线程安全的吗</h1><p>Spring本身并没有针对Bean做线程安全的处理，所以</p>
</li>
<li><p>如果Bean是无状态的，则Bean是线程安全的</p>
</li>
<li><p>有状态，则不安全</p>
</li>
</ul>
<p>另外，Bean是不是线程安全跟Bean作用域没关系，Bean作用域只是表示Bean生命周期的范围</p>
<h1 id="Spring支持的几种bean的作用域"><a href="#Spring支持的几种bean的作用域" class="headerlink" title="Spring支持的几种bean的作用域"></a>Spring支持的几种bean的作用域</h1><ul>
<li>singleton : bean在每个Spring ioc 容器中只有一个实例。单例模式由BeanFactory自身来维护。该对象的生命周期和IOC一致。（在第一次被注入时才会被创建）</li>
<li>prototype：为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象。</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。session过期以后bean会随之失效</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
</ul>
<p>注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h1 id="Spring用到哪些设计模式"><a href="#Spring用到哪些设计模式" class="headerlink" title="Spring用到哪些设计模式"></a>Spring用到哪些设计模式</h1><h1 id="Spring如何解决循环依赖"><a href="#Spring如何解决循环依赖" class="headerlink" title="Spring如何解决循环依赖"></a>Spring如何解决循环依赖</h1><p>关键词：<strong>三级缓存、提前暴露对象、AOP</strong></p>
<ul>
<li><p>总：什么是循环依赖？ </p>
<ul>
<li>A有b属性，B有a属性</li>
<li>bean的创建过程是先实例化–&gt;初始化</li>
<li>A在实例化后初始化时b属性为空，去容器中找B对象 <ul>
<li>有B，不存在循环依赖</li>
<li>无B，创建B，填充a属性 —&gt;容器中去找A 找不到</li>
</ul>
</li>
</ul>
</li>
<li><p>仔细思考发现A对象是存在的，不过不是一个完整状态，只完成了实例化，没有完成初始化。如果调用了某个对象的引用，后期可以先把非完整状态赋值，等后续操作来完成赋值，相当于<strong>提前</strong>暴露了某个不完整对象的引用。所以解决问题的核心在于实例化和初始化分开操作</p>
</li>
<li><p>当所有对象都完成操作实例化之后，还要把对象放入容器中，此时容器中的对象有两个状态 </p>
<ul>
<li>实例化完成但未初始化完成</li>
<li>实例化初始化都完成</li>
</ul>
</li>
<li><p>这两种对象都在容器中，所以要用不同的map结构来进行存储，此时就有一级缓存和二级缓存 </p>
<ul>
<li>一级缓存放完整的对象</li>
<li>二级缓存放非完整对象</li>
</ul>
</li>
<li><p>三级缓存中的value类型是<code>ObjectFactory</code>函数式接口，存在的意义是保证在容器中同名的bean对象只有一个，一个对象如果要被代理，或者说要生成代理对象，那么先需要一个普通对象。普通对象和代理对象不能同时出现在容器中，因此一个对象需要被代理时就需要使用代理对象去覆盖之前的普通对象，在实际调用中是没有办法确定什么时候对象被调用，所以就需要当某个对象被调用时优先判断此对象是否需要被代理，类似一种回调机制的实现，因此传入lambda表达式时可以通过lambda表达式来执行对象覆盖过程</p>
</li>
<li><p>因此所有bean对象在创建时都放在三级缓存中，后续使用中需要被代理则返回代理对象，不需要则返回普通对象</p>
<h1 id="Spring事务的实现方式和原理以及隔离级别"><a href="#Spring事务的实现方式和原理以及隔离级别" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别"></a>Spring事务的实现方式和原理以及隔离级别</h1><p>有两种使用事务的方式：<strong>编程式和申明式</strong></p>
</li>
<li><p>编程式就是调用一些API</p>
</li>
<li><p>申明式例如@Transaction（rollback = “”）</p>
</li>
</ul>
<p>Spring事务隔离级别就是数据库的隔离级别。如果数据库配置RC，Spirng配置RR，则以Spring配置为准，如果Spring设置的隔离级别数据库不支持，那么以数据库为准。</p>
<h1 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h1><h1 id="Spring-Boot、Spring-MVC、Spring区别"><a href="#Spring-Boot、Spring-MVC、Spring区别" class="headerlink" title="Spring Boot、Spring MVC、Spring区别"></a>Spring Boot、Spring MVC、Spring区别</h1><ul>
<li>spring是一个lOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补oOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</li>
<li>springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet，用来接收请求，然后定义了一套路由策略(url到handle的映射)及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端</li>
<li>springboot是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc应用，简化了配置(约定了默认配置)，整合了一系列的解决方案(starter机制) 、 redis、mongodb、es，可以开箱即用<h1 id="Spring-MVC工作流程"><a href="#Spring-MVC工作流程" class="headerlink" title="Spring MVC工作流程"></a>Spring MVC工作流程</h1></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657373543471-ed458042-4315-4721-ada1-74bd612d0947.png#clientId=u33fedc44-1650-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=618&id=ue7b87caf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=772&originWidth=1532&originalType=binary&ratio=1&rotation=0&showTitle=false&size=880863&status=done&style=none&taskId=u39adb972-af8d-446c-979e-2d82723899e&title=&width=1225.6" alt="image.png"></p>
<p>流程说明（重要）:</p>
<ul>
<li>客户端（浏览器）发送请求，直接请求到Dispatcherservlet。</li>
<li>Dispatcherservlet根据请求信息调用HandlerMapping，拿到控制链。&lt;url，handler&gt;的一个Map</li>
<li>Dispatcherservlet调用HandlerAdapter适配器处理</li>
<li>解析到对应的Handler(也就是我们平常说的Controller控制器）</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter会根据把ModelAndView返回给Dispatcherservlet</li>
<li>ViewResolver会根据逻辑view查找实际的view。</li>
<li>Dispaterservlet把返回的Model传给view（视图渲染）</li>
<li>把view返回给请求者（浏览器)</li>
</ul>
<p>Spring MVC主要组件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657374133666-5e0615ed-f2c6-4add-9d47-b14723f89b64.png#clientId=u33fedc44-1650-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=692&id=u49a8df32&margin=%5Bobject%20Object%5D&name=image.png&originHeight=691&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199988&status=done&style=none&taskId=u36c8bfaa-b96f-40a7-9af1-d8834de7606&title=&width=630.2000122070312" alt="image.png"></p>
<h1 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657697784371-eba47024-6dc8-4aee-852e-2cb8a8d8219f.jpeg"><br>@SpringBootApplication可以看作是 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><strong>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</strong></li>
<li>@SpringBootConfiguration：允许在上下文中注册额外的 bean 或导入其他配置类</li>
<li>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除TypeExcludeFilter和AutoConfigurationExcludeFilter。</li>
</ul>
<p><strong>@EnableAutoConfiguration</strong><br>Spring中有很多Enable开头的注解其作用就是借助@Import来收集并注册特定场景相关的Bean，并加载到IOC容器。<br>@EnableAutoConfiguration就是借助@lmport来收集所有符合自动配置条件的bean定义，并加载到IOC容器。</p>
<ul>
<li>@Import（AutoConfigurationImportSelector.class）<ul>
<li>帮助SpringBoot将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IOC容器中。</li>
<li>AutoConfigurationImportSelector类实现了Aware相关接口</li>
<li>其中getImports()中调用selectImports()</li>
</ul>
</li>
<li>@AutoConfigurationPackage<ul>
<li>@Import：导入Registar组件 就干一件事：拿到启动类所在的包名。</li>
</ul>
</li>
</ul>
<h1 id="SpringBoot常用注解及其底层实现原理"><a href="#SpringBoot常用注解及其底层实现原理" class="headerlink" title="SpringBoot常用注解及其底层实现原理"></a>SpringBoot常用注解及其底层实现原理</h1><p>1.@SpringBootApplication注解:这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是:</p>
<ul>
<li>@SpringBootConfiguration:这个注解实际就是一个@Configuration，表示启动类也是一个配置类</li>
<li>.@EnableAutoConfiguration:向Spring容器中导入了一个Selector，用来加载Classpath 下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean</li>
<li>@ComponentScan:标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录</li>
</ul>
<p>2.@Bean注解:用来定义Bean，类似于XML中的<bean>标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象<br>3.@Controller、@Service、@ResponseBody、@Autowired都可以说</p>
<h1 id="如何理解SpringBoot中的starter"><a href="#如何理解SpringBoot中的starter" class="headerlink" title="如何理解SpringBoot中的starter"></a>如何理解SpringBoot中的starter</h1><ul>
<li>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</li>
<li>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在starter包的META-INF/spring.factories中写入该配置类,springboot会按照约定来加载该配置类</li>
<li>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置)，就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot-starter，spring-boot-starter-redis<h1 id="Springboot的启动流程细节"><a href="#Springboot的启动流程细节" class="headerlink" title="Springboot的启动流程细节"></a>Springboot的启动流程细节</h1></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657524571135-80f4d35a-d4fa-45bd-9af1-dad6027fe356.png#clientId=u3e77d754-916e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7361ccd0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1102&originWidth=883&originalType=url&ratio=1&rotation=0&showTitle=false&size=158925&status=done&style=none&taskId=u3e34dc9f-456c-4b13-9516-d9ce2c706f7&title=" alt="image.png"></p>
<p>1、SpringBoot启动的时候，会构造一个SpringApplication的实例，然后调用这个实例的run方法，在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：<br>(1)把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数.<br>(2)判断是否是web程序，并设置到webEnvironment的boolean属性中.<br>(3)创建并初始化ApplicationInitializer，设置到initializers属性中 。<br>(4)创建并初始化ApplicationListener，设置到listeners属性中 。<br>(5)初始化主类mainApplicatioClass。<br>2、SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事：<br>(1)构造一个StopWatch计时器，观察SpringApplication的执行 。<br>(2)获取SpringApplicationRunListeners并封装到SpringApplicationRunListeners中启动，用于监听run方法的执行。<br>(3)创建并初始化ApplicationArguments,获取run方法传递的args参数。<br>(4)创建并初始化ConfigurableEnvironment（环境配置）。<br>(5)打印banner（只用在Classpath下添加字符文件图标，就可以在启动时候打印）。<br>(3)构造Spring容器(ApplicationContext)上下文。<br>(4)SpringApplicationRunListeners发布finish事件。<br>(5)StopWatch计时器停止计时。</p>
<h1 id="MyBatis优缺点"><a href="#MyBatis优缺点" class="headerlink" title="MyBatis优缺点"></a>MyBatis优缺点</h1><p>优点:</p>
<ul>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理;提供XML标签，支持编写动态SQL语句，并可重用。</li>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接;</li>
<li>很好的与各种数据库兼容（因为MyBatis 使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持)。</li>
<li>能够与Spring很好的集成;</li>
<li>供映射标签，支持对象与数据库的ORM字段关系映射;提供对象关系映射标签，支持对象关系组件维护。</li>
</ul>
<p>缺点:</p>
<ul>
<li><p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
</li>
<li><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h1 id="和-区别"><a href="#和-区别" class="headerlink" title="#{} 和 ${}区别"></a>#{} 和 ${}区别</h1></li>
<li><p>#{}是预编译处理是占位符，${}是字符串替换、是拼接符。</p>
</li>
<li><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement来赋值，会有预编译，#对应的变量自动加上单引号；</p>
</li>
<li><p>Mybatis在处理${}时，就是把${}替换成变量的值，是动态参数（比如通过传参动态设置表名，动态设置排序字段），调用Statement来赋值，相当于直接拼接，${}对应的变量不会加上单引号；</p>
</li>
<li><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h1 id="MyBatis二级缓存"><a href="#MyBatis二级缓存" class="headerlink" title="MyBatis二级缓存"></a>MyBatis二级缓存</h1><p>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存 是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以 后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存 是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的 sqlsession 是可以共享的  </p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/22/Spring/" data-id="cld0dkug30003ywvk9pu76wr6" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-计算机网络" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2022-05-21T13:03:41.000Z" itemprop="datePublished">2022-05-21</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/java/">java</a> / <a class="article-category-link" href="/categories/java/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657506890803-2f92c24f-e677-4640-aad6-29370dc5f594.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u82bc0f33&margin=%5Bobject%20Object%5D&originHeight=421&originWidth=731&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3fa4f199-bb77-4569-bce1-4f708cb396f&title="></p>
<h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><p>1、首先，在浏览器地址栏中输入url<br>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。<br>3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。<br>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。<br>5、握手成功后，浏览器向服务器发送http请求，请求数据包。<br>6、服务器处理收到的请求，将数据返回至浏览器<br>7、浏览器收到HTTP响应<br>8、读取页面内容，浏览器渲染，解析html源码<br>9、生成Dom树、解析css样式、js交互<br>10、客户端和服务器交互</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p>
</li>
<li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p>
</li>
<li><p><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p>
<h1 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h1><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456521938-f84cf61e-05a5-4a44-97cd-e58e4a108634.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u947fa551&margin=%5Bobject%20Object%5D&originHeight=1019&originWidth=1221&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e53449d-e6dc-4c0b-8881-4b0c8300f7e&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456537239-5309a313-193a-4ebd-a21c-b4e33a0784ef.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b1b72e4&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=1173&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua41d35f8-a61d-42ff-867f-79c01ad4340&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456545095-0909cf57-8a7f-446b-ab40-2ef35e100fc3.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9eab8a7a&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue2bb6658-e374-492f-91da-95111a8d8e2&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456549423-555f88b7-8905-4768-a92b-1e335c3e5dad.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u03125089&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua46a8691-bb1d-4cfa-8273-ad72aa59ea2&title="></p>
</li>
<li><p>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</p>
</li>
<li><p>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</p>
</li>
<li><p>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</p>
</li>
<li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务器的数据</strong>，之后客户端处于 ESTABLISHED 状态。</p>
</li>
<li><p>服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。</p>
</li>
</ul>
<p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p>
<h2 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h2><ul>
<li><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></li>
<li><strong>三次握手才可以同步双方的初始序列号</strong></li>
<li><strong>三次握手才可以避免资源浪费</strong></li>
</ul>
<h3 id="阻止重复历史连接的初始化（主要原因）"><a href="#阻止重复历史连接的初始化（主要原因）" class="headerlink" title="阻止重复历史连接的初始化（主要原因）"></a>阻止重复历史连接的初始化（主要原因）</h3><p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong><br>我们考虑一个场景，客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的）。<br>客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 SYN + ACK 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li>
</ul>
<p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p>
<h3 id="同步双方的初始序列号"><a href="#同步双方的初始序列号" class="headerlink" title="同步双方的初始序列号"></a>同步双方的初始序列号</h3><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong><br>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。<br>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657456995831-a3b5cee7-a469-4a0a-aa57-5455dfd07f53.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7e94c947&margin=%5Bobject%20Object%5D&originHeight=947&originWidth=1442&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc4f73397-2e2e-4fea-9d8a-6b6d4b453bb&title="></p>
<h3 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h3><p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？<br>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。<br>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li><p>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</p>
</li>
<li><p>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>
<h1 id="第一次握手丢失会发生什么"><a href="#第一次握手丢失会发生什么" class="headerlink" title="第一次握手丢失会发生什么"></a>第一次握手丢失会发生什么</h1><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。<br>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。<br>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<h1 id="第二次握手丢失会发生什么"><a href="#第二次握手丢失会发生什么" class="headerlink" title="第二次握手丢失会发生什么"></a>第二次握手丢失会发生什么</h1><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。<br>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p>
</li>
<li><p>第二次握手里的 ACK， 是对第一次握手的确认报文；</p>
</li>
<li><p>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</p>
</li>
</ul>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。<br>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。<br>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<h1 id="第三次握手丢失会发生什么"><a href="#第三次握手丢失会发生什么" class="headerlink" title="第三次握手丢失会发生什么"></a>第三次握手丢失会发生什么</h1><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。<br>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。<br>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h1 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h1><p>攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务器不能为正常用户服务。<br>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li>
<li>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接。</li>
</ul>
<p><strong>避免方式：</strong></p>
<ol>
<li>修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理</li>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」，计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端。服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」，最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。<h1 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h1>TCP 断开连接是通过<strong>四次挥手</strong>方式。<br>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657458284824-44c6dbf7-9e4b-402e-bb97-47fab2391e3e.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7429d3fe&margin=%5Bobject%20Object%5D&originHeight=794&originWidth=753&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u31713d17-09f1-4320-a1d8-360e535e32d&title="></li>
</ol>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li>
<li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。</li>
<li>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li>
<li>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</li>
<li>服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h2 id="为什么是四次"><a href="#为什么是四次" class="headerlink" title="为什么是四次"></a>为什么是四次</h2><ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h1 id="第一次挥手丢失会发生什么"><a href="#第一次挥手丢失会发生什么" class="headerlink" title="第一次挥手丢失会发生什么"></a>第一次挥手丢失会发生什么</h1><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN_WAIT_1 状态。<br>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 FIN_WAIT2状态。<br>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。<br>当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，直接进入到 close 状态。</p>
<h1 id="第二次挥手丢失会发生什么"><a href="#第二次挥手丢失会发生什么" class="headerlink" title="第二次挥手丢失会发生什么"></a>第二次挥手丢失会发生什么</h1><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。<br>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。<br>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 FIN_WAIT2 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。<br>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以FIN_WAIT2 状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。<br>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。<br>但是注意，如果主动关闭方使用 shutdown 函数关闭连接且指定只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态（tcp_fin_timeout 无法控制 shutdown 关闭的连接）。</p>
<h1 id="第三次挥手丢失会发生什么"><a href="#第三次挥手丢失会发生什么" class="headerlink" title="第三次挥手丢失会发生什么"></a>第三次挥手丢失会发生什么</h1><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。<br>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。<br>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。<br>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<h1 id="第四次挥手丢失会发生什么"><a href="#第四次挥手丢失会发生什么" class="headerlink" title="第四次挥手丢失会发生什么"></a>第四次挥手丢失会发生什么</h1><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。<br>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。<br>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。<br>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p>
<h1 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h1><p>MSL 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。<br>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<br>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。<br>2MSL 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<h1 id="为什么要TIME-WAIT状态"><a href="#为什么要TIME-WAIT状态" class="headerlink" title="为什么要TIME_WAIT状态"></a>为什么要TIME_WAIT状态</h1><ul>
<li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p>
</li>
<li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p>
<h1 id="TCP为啥是可靠的"><a href="#TCP为啥是可靠的" class="headerlink" title="TCP为啥是可靠的"></a>TCP为啥是可靠的</h1><p>TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？<br>为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。<br>那么，TCP 是通过<strong>序列号、确认应答、重发控制、连接管理以及窗口控制</strong>等机制实现可靠性传输的。</p>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。<br>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。<br>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？<br>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459050264-9c22dcd5-b827-447f-b70a-6b00c0a159ea.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua94b36bb&margin=%5Bobject%20Object%5D&originHeight=846&originWidth=1412&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ued85328b-c10c-49d0-84d0-086bc18eca4&title="><br>上图中有两种超时时间不同的情况：</p>
</li>
<li><p>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</p>
</li>
<li><p>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</p>
</li>
</ul>
<p>精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效。<br>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459073826-f018dd25-7288-47f9-82c0-07e4d02fd630.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubae8de8c&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=617&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3fe19c4-ea72-4bad-a23c-bd66c60eaed&title="></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459110193-082587bb-014e-4b8c-9032-cecf428a4887.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud67dd2b9&margin=%5Bobject%20Object%5D&originHeight=602&originWidth=647&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc3f797e0-ef7f-4057-b45b-d724dc47a08&title="></p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong><br>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<h3 id="SACK选择性确认"><a href="#SACK选择性确认" class="headerlink" title="SACK选择性确认"></a>SACK选择性确认</h3><p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459390363-dd685ad6-bd40-4ced-bdf8-3dc001dc1a70.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc09eb19e&margin=%5Bobject%20Object%5D&originHeight=827&originWidth=1413&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc5224ae5-3725-45f9-8e8f-9fdc82b83f4&title="></p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。但这种方式的缺点是效率比较低的。<br>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。<br>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。<br>窗口的实现实际上是操作系统开辟的一个<strong>缓存空间</strong>，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459480149-a3bdfb45-2815-4d33-801f-3692623051f4.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u65896e03&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=1428&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf16a8c9f-feef-40c6-b42b-4e5939dc76c&title="></p>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
<p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 52</del>56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459524511-0327b0f3-4ed4-49a2-a8ac-2896c3549616.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u432e4b08&margin=%5Bobject%20Object%5D&originHeight=408&originWidth=1608&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6e92b946-0c5c-42a6-9022-10fa6049867&title="><br>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657459579804-e07d32e1-48d2-4dc9-8e66-b1e196ea55e2.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udd9a001c&margin=%5Bobject%20Object%5D&originHeight=513&originWidth=1428&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u651d5b82-f0df-4fea-aad1-6c54417f4b8&title="></p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。<br>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。<br>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<br><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong><br>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。<br>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong><br>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。<br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。<br>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。<br>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li><p>只要网络中没有出现拥塞，cwnd 就会增大；</p>
</li>
<li><p>但网络中出现了拥塞，cwnd 就减少；</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？<br>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong><br>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657461768939-be8acba1-fd9f-45c4-a1c7-bb37f6e65332.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udc2211dd&margin=%5Bobject%20Object%5D&originHeight=632&originWidth=1016&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub7fc6573-4c83-42b7-a626-34c727c401b&title="><br>有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。</p>
</li>
<li><p>当 cwnd &lt; ssthresh 时，使用慢启动算法。</p>
</li>
<li><p>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。</p>
<h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。<br>一般来说 ssthresh 的大小是 65535 字节。<br>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong><br>接上前面的慢启动的栗子，现假定 ssthresh 为 8：</p>
</li>
<li><p>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了<strong>线性增长。</strong></p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657461857410-a908980d-c4bb-496a-856c-5ec22b16afd1.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua60403ab&margin=%5Bobject%20Object%5D&originHeight=731&originWidth=872&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u09c01fcb-49bf-4050-bb70-1c35d1fc106&title="><br>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。<br>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>当发生了「<strong>超时重传</strong>」，则就会使用拥塞发生算法。<br>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li>ssthresh 设为 cwnd/2，</li>
<li>cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22222537/1657462092168-b3c9f1b3-e086-4a17-a736-5c53ca236143.jpeg#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a1a80e5&margin=%5Bobject%20Object%5D&originHeight=873&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5c38a9f4-aabb-49a6-be85-2760a7fc4ba&title="></p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p><strong>快速重传</strong>和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。<br>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p>
<ul>
<li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li>
<li>ssthresh = cwnd;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657463742741-743bc69f-3471-4d92-b5f9-81dbc70de2b4.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u02d28309&margin=%5Bobject%20Object%5D&originHeight=873&originWidth=1352&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud229e954-b981-41df-b5ef-2fd578cebda&title="></p>
<h1 id="UDP-TCP？"><a href="#UDP-TCP？" class="headerlink" title="UDP TCP？"></a>UDP TCP？</h1><ul>
<li>UDP是<strong>无连接的</strong>；</li>
<li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP是<strong>面向报文</strong>的；</li>
<li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li>
<li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li>
<li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li>
</ul>
<p>那么，再说一次TCP的特点：</p>
<ul>
<li><p><strong>TCP是面向连接的</strong>。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（<strong>一对一</strong>）；</p>
</li>
<li><p>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</p>
</li>
<li><p>TCP<strong>提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
</li>
<li><p><strong>面向字节流</strong>。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
<h1 id="TCP-Keepalive-和-HTTP-Keep-Alive"><a href="#TCP-Keepalive-和-HTTP-Keep-Alive" class="headerlink" title="TCP Keepalive 和 HTTP Keep-Alive"></a>TCP Keepalive 和 HTTP Keep-Alive</h1><p>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p>
</li>
<li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p>
</li>
<li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p>
<h2 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h2><table>
<thead>
<tr>
<th>Http 1.0 短链接</th>
<th>Http 1.1 长链接</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657504730983-89ddfecf-3f13-4bb8-a93e-7fbbf55b8962.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u839c6483&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1067&originWidth=386&originalType=url&ratio=1&rotation=0&showTitle=false&size=72515&status=done&style=none&taskId=u1f5ed88c-acb7-43f9-8ff6-1f25a4a2dcd&title=" alt="image.png"></td>
<td><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657504758881-a72157de-0634-4dba-bc58-8c4d849f9b27.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1347d142&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1067&originWidth=386&originalType=url&ratio=1&rotation=0&showTitle=false&size=61840&status=done&style=none&taskId=ucfd7e6ed-4e54-4a0e-824b-e5ed5b1cd27&title=" alt="image.png"></td>
</tr>
</tbody></table>
</li>
</ul>
<p>HTTP 的 Keep-Alive 可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。<br><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive。</strong><br>为了避免资源浪费的情况，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<h2 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h2><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657504965949-5cc5a087-49f6-48c7-98c9-2b53bc20b534.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udd592f8c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=810&originWidth=833&originalType=url&ratio=1&rotation=0&showTitle=false&size=67650&status=done&style=none&taskId=u5f8b2031-027a-4f82-bd90-d8dcfb74aa7&title=" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</li>
<li>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。<h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><h2 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h2></li>
</ul>
<ol>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657505887909-c7ca431c-dec5-47ff-8ced-20c8fa0fc250.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u436c7bc2&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=596&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0350652e-608b-4f32-9160-4961ed0ae97&title="><br>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><p><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</p>
</li>
<li><p><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</p>
</li>
<li><p><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2></li>
<li><p><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p>
</li>
<li><p><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p>
</li>
<li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657506133791-a190fe08-e2c0-45fe-8e07-1b921ed067b6.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7235e8ff&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=613&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6742655-c857-4ba2-a1ad-29b2b97815e&title="><br>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
</li>
<li><p>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</p>
</li>
<li><p>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</p>
</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</li>
</ul>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657506280631-2233b593-67d1-48c4-9248-8341b45137e7.png#clientId=u7cca30bd-a35c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9ee13cd5&margin=%5Bobject%20Object%5D&originHeight=577&originWidth=779&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u261c32c4-ceb1-43dd-8182-857282c3317&title="><h1 id="Cookie与Session的对比"><a href="#Cookie与Session的对比" class="headerlink" title="Cookie与Session的对比"></a>Cookie与Session的对比</h1>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</li>
</ul>
<p><strong>Cookie</strong></p>
<ul>
<li>Cookie是客户端保持状态的方法。Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</li>
</ul>
<p><strong>Session</strong></p>
<ul>
<li>Session是服务器保持状态的方法。首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</li>
</ul>
<p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="cld0dkuga000dywvkam1xdnxa" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-Mysql" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h2 class="article-title" itemprop="name">
    <a href="/2022/05/20/Mysql/">MySQL</a>
  </h2>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/05/20/Mysql/" class="article-date">
  <time datetime="2022-05-20T13:03:41.000Z" itemprop="datePublished">2022-05-20</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/java/">java</a> / <a class="article-category-link" href="/categories/java/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
        <h1 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h1><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的</p>
<h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<br>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。<br>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND</p>
<h2 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h2><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方面后面模块获取 SQL 类型、表名、字段名、 where 条件等等。<br>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>我们先来说说预处理阶段做了什么事情。</p>
<ul>
<li>检查 SQL 查询语句中的表或者字段是否存在；</li>
<li>将 select * 中的 * 符号，扩展为表上的所有列<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</li>
</ul>
<p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<ul>
<li><p>逻辑优化查询：怎么查询效率更高</p>
</li>
<li><p>物理优化查询：索引等</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。<br>接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。</p>
</li>
<li><p>主键索引查询</p>
</li>
<li><p>全表扫描</p>
</li>
<li><p>索引下推</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行一条 SQL 查询语句，期间发生了什么？</p>
</li>
<li><p>连接器：建立连接，管理连接、校验用户身份；</p>
</li>
<li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p>
</li>
<li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p>
</li>
<li><p>执行 SQL：执行 SQL 共有三个阶段：</p>
<ul>
<li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333914716-af5bc129-39a9-4b31-8c80-e0ee9d39f500.png#averageHue=%23f2eee8&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uda63ecc3&margin=%5Bobject%20Object%5D&originHeight=721&originWidth=1261&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u34333de7-b2ac-425f-b7d7-94b9014ee47&title="></p>
<h1 id="Mysql-explain-执行计划"><a href="#Mysql-explain-执行计划" class="headerlink" title="Mysql explain 执行计划"></a>Mysql explain 执行计划</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1658305376551-ad5553c7-9e4e-4e53-9ec2-c0f9739a1783.png#averageHue=%23faf9f8&clientId=u2af9f06b-6500-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=177&id=u947cd4cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=909&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38949&status=done&style=none&taskId=u2cecd7c2-0ddf-49fa-9ee1-8c0589c8ac2&title=&width=808" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1658305387675-47f134db-f45f-4722-b9a0-1a88d5de0cf6.png#averageHue=%23faf8f5&clientId=u2af9f06b-6500-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=636&id=u2ba8c273&margin=%5Bobject%20Object%5D&name=image.png&originHeight=715&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&size=312776&status=done&style=none&taskId=uc94e0302-04a5-4e44-8c7c-57f404b0a13&title=&width=852.4444444444445" alt="image.png"></p>
<h1 id="事务的四大特性？"><a href="#事务的四大特性？" class="headerlink" title="事务的四大特性？"></a>事务的四大特性？</h1><p><strong>事务特性ACID</strong>：<strong>原子性</strong>（<code>Atomicity</code>）、<strong>一致性</strong>（<code>Consistency</code>）、<strong>隔离性</strong>（<code>Isolation</code>）、<strong>持久性</strong>（<code>Durability</code>）。</p>
<ul>
<li><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。</li>
<li><strong>隔离性</strong>。跟隔离级别相关，如<code>read committed</code>，一个事务只能读到已经提交的修改。</li>
<li><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1></li>
</ul>
<p><strong>一范式、二范式、三范式、巴斯-科德范式、第四范式、第五范式（完美范式）</strong><br><strong>「第一范式」</strong>：数据库中的字段具有<strong>「原子性」</strong>，不可再分，并且是单一职责</p>
<table>
<thead>
<tr>
<th><strong>国家</strong></th>
<th><strong>省</strong></th>
<th><strong>市</strong></th>
<th><strong>区</strong></th>
<th><strong>街道</strong></th>
</tr>
</thead>
<tbody><tr>
<td>中国</td>
<td>上海</td>
<td>上海</td>
<td>宝山区</td>
<td>上大路99号</td>
</tr>
</tbody></table>
<p><strong>「第二范式」</strong>：<strong>「建立在第一范式的基础上」</strong>，第二范式要求数据库表中的每个实例或行必须<strong>「可以被唯一地区分」</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键。（任何字段只能依赖主键）</p>
<table>
<thead>
<tr>
<th><strong>订单编号</strong></th>
<th><strong>商品编号</strong></th>
<th><strong>用户ID</strong></th>
<th><strong>下单时间</strong></th>
<th><strong>商品名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td>4654641666</td>
<td>4553</td>
<td>2424</td>
<td>2022-07-04</td>
<td>洗衣机</td>
</tr>
</tbody></table>
<p>很显然，商品名称和订单无关，商品名称是依赖商品编号的，这是<strong>部分依赖</strong>！不应该放在同一张表格里面，应该拆成订单表和商品表。<br><strong>「第三范式」</strong>：<strong>「建立在第一，第二范式的基础上」</strong>，确保每列都和主键列直接相关，而不是间接相关不存在其他表的非主键信息<br>其中总价是通过前面两个字段计算得到，数据库不要有数学计算的操作，业务需要的时候通过代码进行计算，不要入库</p>
<table>
<thead>
<tr>
<th><strong>商品</strong></th>
<th><strong>单价</strong></th>
<th><strong>数量</strong></th>
<th><strong>总价</strong></th>
</tr>
</thead>
<tbody><tr>
<td>12456</td>
<td>10</td>
<td>50</td>
<td>500</td>
</tr>
</tbody></table>
<p>但是在我们的日常开发当中，<strong>「并不是所有的表一定要满足三大范式」</strong>，有时候冗余几个字段可以少关联几张表，带来的查询效率的提升有可能是质变的</p>
<h1 id="Order-By-为什么会导致索引失效"><a href="#Order-By-为什么会导致索引失效" class="headerlink" title="Order By 为什么会导致索引失效"></a>Order By 为什么会导致索引失效</h1><ul>
<li><p>字段： a\b\c\d,索引：b\c\d</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c,d;</span><br></pre></td></tr></table></figure>

<ul>
<li>走bcd，不需要排序，n次回表</li>
<li>全表扫描，内存里排库 + 不用回表<h1 id="MySQL锁的类型"><a href="#MySQL锁的类型" class="headerlink" title="MySQL锁的类型"></a>MySQL锁的类型</h1></li>
</ul>
</li>
<li><p>基于锁的分类：共享锁、排他锁</p>
</li>
<li><p>基于锁的粒度：行级锁、表级锁、页级锁、记录锁、间隙锁、临键锁</p>
</li>
<li><p>基于锁的状态：意向共享锁、意向排他锁</p>
<h2 id="表级锁具体内容"><a href="#表级锁具体内容" class="headerlink" title="表级锁具体内容"></a>表级锁具体内容</h2></li>
<li><p>表锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock tables 表名…… read<span class="operator">/</span>write</span><br><span class="line"></span><br><span class="line">lock tables </span><br></pre></td></tr></table></figure>

<ul>
<li>表共享读锁</li>
<li>表独占写锁</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333063981-ebe95b29-107d-44e3-a5cc-11068f72dcba.png#averageHue=%23faf8f8&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u040e3ad1&margin=%5Bobject%20Object%5D&name=image-20220520223417654.png&originHeight=378&originWidth=624&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90321&status=done&style=none&taskId=u566585b9-3435-45f5-acdc-82f86af2bc7&title=" alt="image-20220520223417654.png"></li>
</ul>
</li>
<li><p>元数据锁（共享锁）：在select和update时候都会自动加上</p>
<ul>
<li>系统自动，无需显示使用，访问一张表会自动加上。当这张表上有未提交的事物，就不能修改表结构，被阻塞</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333113221-e980c641-94a1-41cb-afc3-8d561267e904.png#averageHue=%23dfc2be&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uada987dd&margin=%5Bobject%20Object%5D&name=image-20220520224315911.png&originHeight=144&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53834&status=done&style=none&taskId=ub6088401-d761-4d5d-bc59-7ed1c601a2b&title=" alt="image-20220520224315911.png"></li>
</ul>
</li>
<li><p>意向锁</p>
<ul>
<li>一个线程A给一行加了锁。另一个线程B想给整张表加锁，此时会有问题，B就要一帮一行找A给哪一行加了锁，很麻烦。</li>
<li>修改：在A给表加行锁的时候还会有一把意向锁，B要给表上锁的时候就会和意向锁进行兼容，兼容就说明可以给表上锁，否则不行，会处于阻塞状态，直到A行锁释放意向锁释放，B给表上锁</li>
<li>意向锁分为两种：意向共享锁和意向排他锁<ul>
<li>意向共享锁：与表锁共享锁兼容，与表锁排他锁互斥</li>
<li>意向排他锁：与表锁共享锁、表锁排他锁互斥<h2 id="行级锁具体内容"><a href="#行级锁具体内容" class="headerlink" title="行级锁具体内容"></a>行级锁具体内容</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>行锁</p>
<ul>
<li>共享锁：</li>
<li>排他锁：</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333133166-f8db6502-9f48-45ea-920c-c05a2a3b96dd.png#averageHue=%23ddb1ab&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc1624c28&margin=%5Bobject%20Object%5D&name=image-20220520232600766.png&originHeight=161&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30024&status=done&style=none&taskId=uf200cd15-dfda-466d-8b2f-c774f4c864a&title=" alt="image-20220520232600766.png"></li>
</ul>
</li>
<li><p>间隙锁（一个范围，不包含该记录），确保索引间隙不变，防止其他事务在这个间隙进行insert导致幻读</p>
</li>
<li><p>临键锁：行锁+间隙锁，同时锁住数据和间隙</p>
<h1 id="MySQL数据库中什么情况下索引无法使用"><a href="#MySQL数据库中什么情况下索引无法使用" class="headerlink" title="MySQL数据库中什么情况下索引无法使用"></a>MySQL数据库中什么情况下索引无法使用</h1></li>
<li><p>不符合最左匹配原则</p>
</li>
<li><p>字段进行了隐私数据类型转化</p>
</li>
<li><p>走索引没有全表扫描效率高</p>
<h1 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h1></li>
<li><p>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</p>
</li>
<li><p>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</p>
</li>
<li><p>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<h1 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h1><table>
<thead>
<tr>
<th><strong>myISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td>不支持事务，每次查询都是原子的</td>
<td>ACID，事务，支持四种隔离级别</td>
</tr>
<tr>
<td>表锁</td>
<td>行锁，支持并发写</td>
</tr>
<tr>
<td>无MVCC</td>
<td>MVCC</td>
</tr>
<tr>
<td>三个文件：索引文件、表结构文件、数据文件</td>
<td>除了主键以外，其他索引只存储索引内容</td>
</tr>
<tr>
<td>存储了表的总行数</td>
<td>没有存表行数</td>
</tr>
<tr>
<td>索引数据分开</td>
<td>主键索引文件存了所有的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<p>注意：MyISAM引擎的主键索引，B+数的叶子节点存储的是主键和</p>
<h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><ul>
<li><p>MVCC 多版本并发控制，读取的时候通过快照的方式将数据存下来，这样读锁写锁不冲突，不同事物session会看到自己的版本链</p>
</li>
<li><p>MVCC只在已提交读和可重复读两个隔离级别下工作</p>
</li>
<li><p>InnoDB在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录回滚的版本号。</p>
</li>
<li><p>聚簇索引记录中有3个隐藏列 trx_id 和roll_pointer和ROW_ID</p>
<ul>
<li>trx_id：用来存储每一次对某条聚簇索引记录修改时的事务id</li>
<li>roll_pointer：修改时，将老版本写入undo log中，roll_pointer存了一个指针，指向上一个版本记录的位置，通过它来获得上一条记录的信息</li>
<li>ROW_ID：隐藏主键，如果表结构没有指定主键，将会生成隐藏字段</li>
</ul>
</li>
<li><p>已提交读和可重复读的区别在于他们生成的ReadView策略不同</p>
<ul>
<li>开始事务时创建ReadView，维护事务的id（即未提交的事务），排成一个数组</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333223780-4c02d9c3-5164-4eee-a728-213900de5c01.png#averageHue=%23f7f7f7&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u89562f65&margin=%5Bobject%20Object%5D&name=image-20220509110016131.png&originHeight=191&originWidth=653&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15489&status=done&style=none&taskId=u76b3800c-7c2b-4cc3-9364-e7abca2150b&title=" alt="image-20220509110016131.png"><ul>
<li>已提交读：事务每次查询开始都声称一个独立的ReadView</li>
<li>可重复读：第一次读的时候生成一个ReadView，之后复用之前的ReadView</li>
</ul>
</li>
</ul>
</li>
<li><p>通过版本链实现并发读写。通过ReadView生成策略的不同实现不同的隔离级别</p>
<h1 id="什么是脏读、幻读、不可重复读"><a href="#什么是脏读、幻读、不可重复读" class="headerlink" title="什么是脏读、幻读、不可重复读"></a>什么是脏读、幻读、不可重复读</h1></li>
<li><p>脏读：一个事务修改了一个值，但是需要回滚 回滚前另一个事务读到了被修改后的值</p>
</li>
<li><p>幻读：一个事务插入了一条数据。插入前后另一个事务分别读取，读取的记录数不一样</p>
</li>
<li><p>不可重复读：一个事务修改前后，另一个事务读到的数据不一致</p>
<h1 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h1></li>
<li><p>ACID</p>
<ul>
<li>原子性：全执行/不执行</li>
<li>一致性：</li>
<li>隔离性：事务事物之间互不干扰</li>
<li>持久性：写在磁盘</li>
</ul>
</li>
<li><p>隔离级别</p>
<ul>
<li>读未提交：脏读 幻读 不可重复读</li>
<li>读已提交：幻读 不可重复读</li>
<li>可重复读：幻读(可通过临键锁解决)</li>
<li>串行化：（大量的锁 容易导致死锁）<h1 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h1>事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。<br>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。<br>每当有修改事务时，还会产生undo log，如果需要回滚，则根据undo log 的反向语句进行逻辑操作，比如insert一条记录就delete一条记录。undo log主要实现数据库的一致性。</li>
</ul>
</li>
</ul>
<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ul>
<li>功能逻辑上：普通索引、唯一索引、全文索引、单列索引</li>
<li>物理实现：聚簇索引、非聚簇索引</li>
<li>作用字段个数：单列索引、联合索引</li>
</ul>
<p><strong>普通索引：</strong>可以在任何数据类型<br><strong>唯一索引：</strong>该值必须唯一，允许有空值，比如邮箱、身份证、手机号<br><strong>主键索引：</strong>聚簇索引、非聚簇索引<br><strong>单列索引：</strong>一个字段<br><strong>联合索引：</strong>idx_id_name_gender 多个字段，使用要遵守<strong>最左前缀原则</strong></p>
<h1 id="什么是索引覆盖"><a href="#什么是索引覆盖" class="headerlink" title="什么是索引覆盖"></a>什么是索引覆盖</h1><p>SQL执行的时候可以利用索引快速查找。字段在索引中都包含了，不需要回表，所有数据都在叶子节点上.</p>
<ul>
<li>理解方式1：索引是高校找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此他不必读取整个行，毕竟索引叶子节点储存了他们的索引数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了，<strong>一个索引包含了满足查询结果的所有数据就叫组覆盖索引</strong></li>
<li>理解方式2：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN、WHERE子句中做到所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）</li>
</ul>
<p>简单地说就是：索引列+主键 包含SELECT到FROM之间的查询列</p>
<h1 id="聚集索引、非聚集索引"><a href="#聚集索引、非聚集索引" class="headerlink" title="聚集索引、非聚集索引"></a>聚集索引、非聚集索引</h1><ul>
<li><p>InnoDB中，主键索引和每一条数据都放在同一个文件中。聚集索引的叶子节点包含了完整的数据记录</p>
</li>
<li><p>MyISAM的索引和主键分别放在myi和myd中，每次查询的时候从myi查到数据的存放位置，然后去myd中查出来，类似于一种回表的操作</p>
<h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h2><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p>
</li>
<li><p>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</p>
</li>
<li><p>二级索引的叶子节点存放的是主键值，而不是实际数据。</p>
</li>
</ul>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。<br>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li>
</ul>
<p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。<br>二级索引的 B+ 树如下图，数据部分为主键值：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657334316183-212c9bda-c218-41a8-972d-ca65855f7155.png#averageHue=%23f8f1e9&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua6c5e8d6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=97395&status=done&style=none&taskId=u1965a9e1-deb9-4dcf-bd97-0e0e36a792f&title=" alt="image.png"><br>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p>
<h1 id="MySQL三大日志-binlog、redo-log和undo-log-详解"><a href="#MySQL三大日志-binlog、redo-log和undo-log-详解" class="headerlink" title="MySQL三大日志(binlog、redo log和undo log)详解"></a>MySQL三大日志(binlog、redo log和undo log)详解</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333329885-3b7fdef7-9a04-4283-a545-d62272fa75c7.png#averageHue=%23999b98&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u12a38d1a&margin=%5Bobject%20Object%5D&name=image-20220613161321165.png&originHeight=236&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65469&status=done&style=none&taskId=ud265d115-b908-46ab-a15e-74dc19c3f38&title=" alt="image-20220613161321165.png"></p>
<ul>
<li>redo log:（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。<ul>
<li>比如 MySQL 实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。</li>
<li>MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。</li>
<li>后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</li>
<li>更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。</li>
<li><strong>然后会把“在某个数据页上做了什么修改，比如页号xxx,偏移量yyy，写入了zzz数据”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</strong>（物理级别的修改）</li>
</ul>
</li>
<li>binlog<ul>
<li>redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。</li>
<li>而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</li>
<li>在事务执行的过程中，redo log会不断顺序记录，直到这个给事务提交，才会一次性写到bin log 中。</li>
</ul>
</li>
<li>undo log<ul>
<li>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</li>
<li>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</li>
</ul>
</li>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。<h1 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h1></li>
</ul>
<p><strong>(1)</strong> 为什么要做主从复制？<br>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。<br>2、做数据的热备<br>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。<br><strong>(2)</strong> 什么是mysql的主从复制<br>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用<strong>异步</strong>复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。<br><strong>(3)</strong> 主从复制原理</p>
<ol>
<li>master服务器将数据的改变记录在二进制binlog日志上，当master上的数据发生改变时，将其写入二进制文件中;</li>
<li>slave服务器会在一定时间间隔内对master二进制日志进行探测是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件</li>
<li>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制时间，并保存至 从节点 本地的中继日志中，从节点 将启动sql线程从中继日志中读取二进制日志，在本地释放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</li>
</ol>
<p>简单说：</p>
<ul>
<li><p>从库会生成两个线程,一个I/O线程,一个SQL线程;</p>
</li>
<li><p>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</p>
</li>
<li><p>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</p>
</li>
<li><p>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行。</p>
<h1 id="Innodb如何实现事务（update语句为例）"><a href="#Innodb如何实现事务（update语句为例）" class="headerlink" title="Innodb如何实现事务（update语句为例）"></a>Innodb如何实现事务（update语句为例）</h1></li>
<li><p>Buffer Pool: update语句—&gt; 找到数据所在页-&gt; 缓存在Buffer Pool中</p>
</li>
<li><p>执行update语句 修改Buffer pool中的数据</p>
</li>
<li><p>针对update语句生成redolog对象，存入logBuffer中</p>
</li>
<li><p>针对update语句生成undo日志作为回滚使用</p>
</li>
<li><p>如果事务提交，Redolog持久化，后续有机制将BufferPool 中所修改的数据页持久化到磁盘中</p>
</li>
<li><p>如果事务回滚，则用undo日志进行回滚</p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1659944815452-bf46871a-de0e-4118-b912-69b3a44f67c7.png#averageHue=%23f0f0df&clientId=u6df81462-1dfc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf18b65c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1068&originWidth=1090&originalType=url&ratio=1&rotation=0&showTitle=false&size=808043&status=done&style=none&taskId=uf3a17778-a0ef-4a90-ac84-08c1ca33665&title=" alt="image.png"></p>
<h1 id="Innodb-事务为什么要两阶段提交"><a href="#Innodb-事务为什么要两阶段提交" class="headerlink" title="Innodb 事务为什么要两阶段提交?"></a>Innodb 事务为什么要两阶段提交?</h1></li>
<li><p>两段式提交，就是我们先把这次更新写入到redolog中，并设redolog为prepare状态，然后再写入binlog,写完binlog之后再提交事务，并设redolog为commit状态。也就是把redolog拆成了prepare和commit两段！</p>
</li>
<li><p>其实redolog是后来才加上的，binlog是之前就有的。一开始存储引擎只有MyISAM,后来才有的InnoDB,然后MyISAM没有事务，没有crash-safe的能力。所以InnoDB搞了个redolog。然后<strong>为了保证两份日志同步，所以才有了两段式提交</strong>。</p>
</li>
<li><p>你假设一下如果先保存好redolog,然后再记录binlog。如果redolog写好了之后挂了。ok你看起来好像是没问题了，但是你的binlog还没记录，所以这条记录就少了！如果你备份这份binlog之后，你这条记录就永远的少了！</p>
</li>
<li><p>那如果先写binlog再写redolog呢？那binlog写完了，你数据库挂了，那redolog是不是没有，没有的意思就是你以前你没更新成功。但是binlog已经记录好了，在它那边反正是成功了，所以那备份的binlog也不对！</p>
<h1 id="WAl-是什么-有什么好处"><a href="#WAl-是什么-有什么好处" class="headerlink" title="WAl 是什么?有什么好处?"></a>WAl 是什么?有什么好处?</h1><p>WAI主要先写日志、再写磁盘</p>
</li>
</ul>
<p><strong>WAL(Write Ahead Log)预写日志，是数据库系统中常见的一种手段，用于：</strong><br>1、保证数据操作的原子性和持久性。<br>2、使得随机写变为顺序写提高性能。<br><strong>WAL 的优点：</strong></p>
<ol>
<li>读和写可以完全地并发执行，不会互相阻塞（但是写之间仍然不能并发）。</li>
<li>WAL 在大多数情况下，拥有更好的性能（因为无需每次写入时都要写两个文件）。</li>
<li>磁盘 I/O 行为更容易被预测。</li>
<li>使用更少的 fsync()操作，减少系统脆弱的问题。<h1 id="什么是索引下推-INDEX-CONDITION-PUSHDOWN"><a href="#什么是索引下推-INDEX-CONDITION-PUSHDOWN" class="headerlink" title="什么是索引下推? INDEX CONDITION PUSHDOWN"></a>什么是索引下推? INDEX CONDITION PUSHDOWN</h1>索引下推是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。<br>例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> S1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>对于我们理解的而言，查询的顺序应该是：<ul>
<li>先找到 key1 &gt; ‘z’的行，然后回表查询，最后筛选key1 LIKE ‘%a’的数据返回</li>
</ul>
</li>
<li>但是对于查询优化器而言：<ul>
<li>先找到 key1 &gt; ‘z’的行，这个时候先不回表，继续执行key1 LIKE ‘%a’，直接在索引中挑选出来，最后把符合这两个条件的数据进行回表查找。此时减少了回表的次数</li>
</ul>
</li>
</ul>
<p>例如：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657333401038-cf3aa45a-aacc-40da-a002-3aa628617fdb.png#averageHue=%23f6f1e8&clientId=ue1be819a-bbaf-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0b9f2241&margin=%5Bobject%20Object%5D&name=image-20220612210116273.png&originHeight=186&originWidth=370&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75911&status=done&style=none&taskId=ud6fa5de9-5f15-4f81-bb51-408da160276&title=" alt="image-20220612210116273.png"><br>索引为zipcode,lastname,address 联合索引</p>
<ul>
<li>索引中包含了后面查询田中的字段，在回表前索引下推机制是会先做判断的<h1 id="一条-Sql-语句查询偶尔慢会是什么原因"><a href="#一条-Sql-语句查询偶尔慢会是什么原因" class="headerlink" title="一条 Sql 语句查询偶尔慢会是什么原因?"></a>一条 Sql 语句查询偶尔慢会是什么原因?</h1></li>
</ul>
<ol>
<li><strong>数据库刷新脏页</strong>当我们要往数据库中插入一条数据或者更新一条数据时，数据库会在内存中把对应字段的数据更新了，但是更新完毕之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到redo log日志中去，只有等到空闲的时候才会通过redo log里的日志把最新的数据同步到磁盘里。这里redo log的容量是有限的，所以如果数据库一直很忙且更新有很频繁，那么这个时候redo log很快就会被写满，从而没办法等到空闲时再把数据同步到磁盘，只能暂停其他操作，全身心来把数据同步到磁盘中去，造成的表象就是我们平时正常的SQL语句突然会执行的很慢。<strong>也就是说，数据库在同步数据到磁盘的时候就有可能会导致我们的SQL语句执行的很慢。</strong></li>
<li><strong>无法获取锁资源执行的时候遇到了表锁或者行锁。</strong>如果我们要执行的SQL语句，其涉及到的表正好别人在用并且加锁了，或者表并没有加锁，但是要使用到的某一行被加锁了，那么我们便无法获取锁，只能慢慢等待别人释放锁了。如果要判断是否真的在等待锁资源，我们可以使用”show processlist”命令来查看当前的状态。<h1 id="主从延迟要怎么解决"><a href="#主从延迟要怎么解决" class="headerlink" title="主从延迟要怎么解决?"></a>主从延迟要怎么解决?</h1></li>
</ol>
<ul>
<li><p>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</p>
</li>
<li><p>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</p>
</li>
<li><p>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</p>
</li>
<li><p>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</p>
<h1 id="删除表数据后表的大小却没有变动-这是为什么"><a href="#删除表数据后表的大小却没有变动-这是为什么" class="headerlink" title="删除表数据后表的大小却没有变动,这是为什么?"></a>删除表数据后表的大小却没有变动,这是为什么?</h1><p>1、释放这些空间的操作本身就需要时间，如果每次删除数据都去进行这个操作，显然会影响性。<br>2、第二个原因则是因为表里后续还是会有新的数据插入，这些删除的数据空间可以在新的数据插入进来后重新利用即可，这样也避免了新增数据要去重新申请新的空间。</p>
<h1 id="为什么-VarChar-建议不要超过255"><a href="#为什么-VarChar-建议不要超过255" class="headerlink" title="为什么 VarChar 建议不要超过255?"></a>为什么 VarChar 建议不要超过255?</h1><p>首先VARCHAR不是定长的，而是可变的，所以一般业务开发我们都要尽量使用最小的长度来满足需求，以免浪费空间，影响性能，而既然是可变的长度，那就得有保存长度的地方，所以如果VARCHAR的长度设置在255以下，那只会使用额外一个字节来保存长度，但是如果VARCHAR的长度设置在255以上，那么就会使用额外的两个字节来保存长度，无形中就浪费了存储空间。</p>
<h1 id="Redis和MySQL如何保证数据的一致性"><a href="#Redis和MySQL如何保证数据的一致性" class="headerlink" title="Redis和MySQL如何保证数据的一致性"></a>Redis和MySQL如何保证数据的一致性</h1><p>问题：一份数据同时保存在数据库里和redis里面，数据发生变化的时候redis和MySQL变化是有先后顺序的</p>
</li>
<li><p>先更新数据库再更新缓存/先更新缓存再更新数据库</p>
<ul>
<li>一个改还没同步，另一个查 不一致</li>
</ul>
</li>
<li><p>先删除缓存再更新数据库</p>
</li>
<li><p>延时双删</p>
</li>
</ul>
<p>保证高一致性：<br>MQ手动应答确保redis删除<br>Canal组件监听binlog日志</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/20/Mysql/" data-id="cld0dkug00001ywvkfnn8gngi" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>Winky&#39;s Blog &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-bar-chart tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Winky&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>